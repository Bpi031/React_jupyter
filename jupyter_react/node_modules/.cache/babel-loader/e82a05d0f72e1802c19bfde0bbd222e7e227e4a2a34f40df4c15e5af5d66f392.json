{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { __asyncGenerator, __asyncValues, __await } from \"tslib\";\nimport { createStream, ensureAsyncIterable } from \"./utils.js\";\nexport function createSseStream(chunkStream) {\n  const {\n    cancel,\n    iterable\n  } = ensureAsyncIterable(chunkStream);\n  const asyncIter = toMessage(toLine(iterable));\n  return createStream(asyncIter, cancel);\n}\nfunction concatBuffer(a, b) {\n  const res = new Uint8Array(a.length + b.length);\n  res.set(a);\n  res.set(b, a.length);\n  return res;\n}\nfunction createMessage() {\n  return {\n    data: undefined,\n    event: \"\",\n    id: \"\",\n    retry: undefined\n  };\n}\nfunction toLine(chunkIter) {\n  return __asyncGenerator(this, arguments, function* toLine_1() {\n    var _a, e_1, _b, _c;\n    let buf;\n    let bufIdx = 0;\n    let fieldLen = -1;\n    let discardTrailingNewline = false;\n    try {\n      for (var _d = true, chunkIter_1 = __asyncValues(chunkIter), chunkIter_1_1; chunkIter_1_1 = yield __await(chunkIter_1.next()), _a = chunkIter_1_1.done, !_a; _d = true) {\n        _c = chunkIter_1_1.value;\n        _d = false;\n        const chunk = _c;\n        if (buf === undefined) {\n          buf = chunk;\n          bufIdx = 0;\n          fieldLen = -1;\n        } else {\n          buf = concatBuffer(buf, chunk);\n        }\n        const bufLen = buf.length;\n        let start = 0;\n        while (bufIdx < bufLen) {\n          if (discardTrailingNewline) {\n            if (buf[bufIdx] === 10 /* ControlChars.NewLine */) {\n              start = ++bufIdx;\n            }\n            discardTrailingNewline = false;\n          }\n          let end = -1;\n          for (; bufIdx < bufLen && end === -1; ++bufIdx) {\n            switch (buf[bufIdx]) {\n              case 58 /* ControlChars.Colon */:\n                if (fieldLen === -1) {\n                  fieldLen = bufIdx - start;\n                }\n                break;\n              case 13 /* ControlChars.CarriageReturn */:\n                // We need to discard the trailing newline if any but can't do\n                // that now because we need to dispatch the current line first.\n                discardTrailingNewline = true;\n                end = bufIdx;\n                break;\n              case 10 /* ControlChars.NewLine */:\n                end = bufIdx;\n                break;\n            }\n          }\n          if (end === -1) {\n            // We reached the end of the buffer but the line hasn't ended.\n            // Wait for the next chunk and then continue parsing:\n            break;\n          }\n          yield yield __await({\n            line: buf.subarray(start, end),\n            fieldLen\n          });\n          start = bufIdx; // we're now on the next line\n          fieldLen = -1;\n        }\n        if (start === bufLen) {\n          buf = undefined;\n        } else if (start !== 0) {\n          // discard already processed lines\n          buf = buf.subarray(start);\n          bufIdx -= start;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (!_d && !_a && (_b = chunkIter_1.return)) yield __await(_b.call(chunkIter_1));\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  });\n}\nfunction toMessage(lineIter) {\n  return __asyncGenerator(this, arguments, function* toMessage_1() {\n    var _a, e_2, _b, _c;\n    let message = createMessage();\n    const decoder = new TextDecoder();\n    try {\n      for (var _d = true, lineIter_1 = __asyncValues(lineIter), lineIter_1_1; lineIter_1_1 = yield __await(lineIter_1.next()), _a = lineIter_1_1.done, !_a; _d = true) {\n        _c = lineIter_1_1.value;\n        _d = false;\n        const {\n          line,\n          fieldLen\n        } = _c;\n        if (line.length === 0 && message.data !== undefined) {\n          // empty line denotes end of message. Yield and start a new message:\n          yield yield __await(message);\n          message = createMessage();\n        } else if (fieldLen > 0) {\n          // exclude comments and lines with no values\n          // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n          // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n          const field = decoder.decode(line.subarray(0, fieldLen));\n          const valueOffset = fieldLen + (line[fieldLen + 1] === 32 /* ControlChars.Space */ ? 2 : 1);\n          const value = decoder.decode(line.subarray(valueOffset));\n          switch (field) {\n            case \"data\":\n              message.data = message.data ? message.data + \"\\n\" + value : value;\n              break;\n            case \"event\":\n              message.event = value;\n              break;\n            case \"id\":\n              message.id = value;\n              break;\n            case \"retry\":\n              {\n                const retry = parseInt(value, 10);\n                if (!isNaN(retry)) {\n                  message.retry = retry;\n                }\n                break;\n              }\n          }\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (!_d && !_a && (_b = lineIter_1.return)) yield __await(_b.call(lineIter_1));\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n  });\n}","map":{"version":3,"names":["createStream","ensureAsyncIterable","createSseStream","chunkStream","cancel","iterable","asyncIter","toMessage","toLine","concatBuffer","a","b","res","Uint8Array","length","set","createMessage","data","undefined","event","id","retry","chunkIter","buf","bufIdx","fieldLen","discardTrailingNewline","_d","chunkIter_1","__asyncValues","chunkIter_1_1","__await","next","_a","done","_c","value","chunk","bufLen","start","end","line","subarray","lineIter","message","decoder","TextDecoder","lineIter_1","lineIter_1_1","field","decode","valueOffset","parseInt","isNaN"],"sources":["/workspaces/codespaces-blank/jupyter_react/node_modules/@azure/core-sse/src/sse.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { IncomingMessage } from \"http\";\nimport { EventMessage, EventMessageStream, PartialSome } from \"./models.js\";\nimport { createStream, ensureAsyncIterable } from \"./utils.js\";\n\nconst enum ControlChars {\n  NewLine = 10,\n  CarriageReturn = 13,\n  Space = 32,\n  Colon = 58,\n}\n\n/**\n * Processes a response stream into a stream of events.\n * @param chunkStream - A stream of Uint8Array chunks\n * @returns An async iterable of EventMessage objects\n */\nexport function createSseStream(chunkStream: ReadableStream<Uint8Array>): EventMessageStream;\n/**\n * Processes a response stream into a stream of events.\n * @param chunkStream - An async iterable of Uint8Array chunks\n * @returns An async iterable of EventMessage objects\n */\nexport function createSseStream(chunkStream: IncomingMessage): EventMessageStream;\nexport function createSseStream(\n  chunkStream: IncomingMessage | ReadableStream<Uint8Array>,\n): EventMessageStream {\n  const { cancel, iterable } = ensureAsyncIterable(chunkStream);\n  const asyncIter = toMessage(toLine(iterable));\n  return createStream(asyncIter, cancel);\n}\n\nfunction concatBuffer(a: Uint8Array, b: Uint8Array): Uint8Array {\n  const res = new Uint8Array(a.length + b.length);\n  res.set(a);\n  res.set(b, a.length);\n  return res;\n}\n\nfunction createMessage(): PartialSome<EventMessage, \"data\"> {\n  return {\n    data: undefined,\n    event: \"\",\n    id: \"\",\n    retry: undefined,\n  };\n}\n\nasync function* toLine(\n  chunkIter: AsyncIterable<Uint8Array>,\n): AsyncIterable<{ line: Uint8Array; fieldLen: number }> {\n  let buf: Uint8Array | undefined;\n  let bufIdx = 0;\n  let fieldLen = -1;\n  let discardTrailingNewline = false;\n  for await (const chunk of chunkIter) {\n    if (buf === undefined) {\n      buf = chunk;\n      bufIdx = 0;\n      fieldLen = -1;\n    } else {\n      buf = concatBuffer(buf, chunk);\n    }\n    const bufLen = buf.length;\n    let start = 0;\n    while (bufIdx < bufLen) {\n      if (discardTrailingNewline) {\n        if (buf[bufIdx] === ControlChars.NewLine) {\n          start = ++bufIdx;\n        }\n        discardTrailingNewline = false;\n      }\n      let end = -1;\n      for (; bufIdx < bufLen && end === -1; ++bufIdx) {\n        switch (buf[bufIdx]) {\n          case ControlChars.Colon:\n            if (fieldLen === -1) {\n              fieldLen = bufIdx - start;\n            }\n            break;\n          case ControlChars.CarriageReturn:\n            // We need to discard the trailing newline if any but can't do\n            // that now because we need to dispatch the current line first.\n            discardTrailingNewline = true;\n            end = bufIdx;\n            break;\n          case ControlChars.NewLine:\n            end = bufIdx;\n            break;\n        }\n      }\n      if (end === -1) {\n        // We reached the end of the buffer but the line hasn't ended.\n        // Wait for the next chunk and then continue parsing:\n        break;\n      }\n      yield { line: buf.subarray(start, end), fieldLen };\n      start = bufIdx; // we're now on the next line\n      fieldLen = -1;\n    }\n    if (start === bufLen) {\n      buf = undefined;\n    } else if (start !== 0) {\n      // discard already processed lines\n      buf = buf.subarray(start);\n      bufIdx -= start;\n    }\n  }\n}\n\nasync function* toMessage(\n  lineIter: AsyncIterable<{ line: Uint8Array; fieldLen: number }>,\n): AsyncIterableIterator<EventMessage> {\n  let message = createMessage();\n  const decoder = new TextDecoder();\n  for await (const { line, fieldLen } of lineIter) {\n    if (line.length === 0 && message.data !== undefined) {\n      // empty line denotes end of message. Yield and start a new message:\n      yield message as EventMessage;\n      message = createMessage();\n    } else if (fieldLen > 0) {\n      // exclude comments and lines with no values\n      // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n      // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n      const field = decoder.decode(line.subarray(0, fieldLen));\n      const valueOffset = fieldLen + (line[fieldLen + 1] === ControlChars.Space ? 2 : 1);\n      const value = decoder.decode(line.subarray(valueOffset));\n\n      switch (field) {\n        case \"data\":\n          message.data = message.data ? message.data + \"\\n\" + value : value;\n          break;\n        case \"event\":\n          message.event = value;\n          break;\n        case \"id\":\n          message.id = value;\n          break;\n        case \"retry\": {\n          const retry = parseInt(value, 10);\n          if (!isNaN(retry)) {\n            message.retry = retry;\n          }\n          break;\n        }\n      }\n    }\n  }\n}\n"],"mappings":"AAAA;AACA;;AAIA,SAASA,YAAY,EAAEC,mBAAmB,QAAQ,YAAY;AAqB9D,OAAM,SAAUC,eAAeA,CAC7BC,WAAyD;EAEzD,MAAM;IAAEC,MAAM;IAAEC;EAAQ,CAAE,GAAGJ,mBAAmB,CAACE,WAAW,CAAC;EAC7D,MAAMG,SAAS,GAAGC,SAAS,CAACC,MAAM,CAACH,QAAQ,CAAC,CAAC;EAC7C,OAAOL,YAAY,CAACM,SAAS,EAAEF,MAAM,CAAC;AACxC;AAEA,SAASK,YAAYA,CAACC,CAAa,EAAEC,CAAa;EAChD,MAAMC,GAAG,GAAG,IAAIC,UAAU,CAACH,CAAC,CAACI,MAAM,GAAGH,CAAC,CAACG,MAAM,CAAC;EAC/CF,GAAG,CAACG,GAAG,CAACL,CAAC,CAAC;EACVE,GAAG,CAACG,GAAG,CAACJ,CAAC,EAAED,CAAC,CAACI,MAAM,CAAC;EACpB,OAAOF,GAAG;AACZ;AAEA,SAASI,aAAaA,CAAA;EACpB,OAAO;IACLC,IAAI,EAAEC,SAAS;IACfC,KAAK,EAAE,EAAE;IACTC,EAAE,EAAE,EAAE;IACNC,KAAK,EAAEH;GACR;AACH;AAEA,SAAgBV,MAAMA,CACpBc,SAAoC;;;IAEpC,IAAIC,GAA2B;IAC/B,IAAIC,MAAM,GAAG,CAAC;IACd,IAAIC,QAAQ,GAAG,CAAC,CAAC;IACjB,IAAIC,sBAAsB,GAAG,KAAK;;MAClC,KAA0B,IAAAC,EAAA,SAAAC,WAAA,GAAAC,aAAA,CAAAP,SAAS,GAAAQ,aAAA,EAAAA,aAAA,SAAAC,OAAA,CAAAH,WAAA,CAAAI,IAAA,KAAAC,EAAA,GAAAH,aAAA,CAAAI,IAAA,GAAAD,EAAA,EAAAN,EAAA,SAAE;QAAXQ,EAAA,GAAAL,aAAA,CAAAM,KAAA;QAAAT,EAAA;QAAf,MAAMU,KAAK,GAAAF,EAAA;QACpB,IAAIZ,GAAG,KAAKL,SAAS,EAAE;UACrBK,GAAG,GAAGc,KAAK;UACXb,MAAM,GAAG,CAAC;UACVC,QAAQ,GAAG,CAAC,CAAC;QACf,CAAC,MAAM;UACLF,GAAG,GAAGd,YAAY,CAACc,GAAG,EAAEc,KAAK,CAAC;QAChC;QACA,MAAMC,MAAM,GAAGf,GAAG,CAACT,MAAM;QACzB,IAAIyB,KAAK,GAAG,CAAC;QACb,OAAOf,MAAM,GAAGc,MAAM,EAAE;UACtB,IAAIZ,sBAAsB,EAAE;YAC1B,IAAIH,GAAG,CAACC,MAAM,CAAC,oCAA2B;cACxCe,KAAK,GAAG,EAAEf,MAAM;YAClB;YACAE,sBAAsB,GAAG,KAAK;UAChC;UACA,IAAIc,GAAG,GAAG,CAAC,CAAC;UACZ,OAAOhB,MAAM,GAAGc,MAAM,IAAIE,GAAG,KAAK,CAAC,CAAC,EAAE,EAAEhB,MAAM,EAAE;YAC9C,QAAQD,GAAG,CAACC,MAAM,CAAC;cACjB;gBACE,IAAIC,QAAQ,KAAK,CAAC,CAAC,EAAE;kBACnBA,QAAQ,GAAGD,MAAM,GAAGe,KAAK;gBAC3B;gBACA;cACF;gBACE;gBACA;gBACAb,sBAAsB,GAAG,IAAI;gBAC7Bc,GAAG,GAAGhB,MAAM;gBACZ;cACF;gBACEgB,GAAG,GAAGhB,MAAM;gBACZ;YACJ;UACF;UACA,IAAIgB,GAAG,KAAK,CAAC,CAAC,EAAE;YACd;YACA;YACA;UACF;UACA,YAAAT,OAAA,CAAM;YAAEU,IAAI,EAAElB,GAAG,CAACmB,QAAQ,CAACH,KAAK,EAAEC,GAAG,CAAC;YAAEf;UAAQ,CAAE;UAClDc,KAAK,GAAGf,MAAM,CAAC,CAAC;UAChBC,QAAQ,GAAG,CAAC,CAAC;QACf;QACA,IAAIc,KAAK,KAAKD,MAAM,EAAE;UACpBf,GAAG,GAAGL,SAAS;QACjB,CAAC,MAAM,IAAIqB,KAAK,KAAK,CAAC,EAAE;UACtB;UACAhB,GAAG,GAAGA,GAAG,CAACmB,QAAQ,CAACH,KAAK,CAAC;UACzBf,MAAM,IAAIe,KAAK;QACjB;MACF;;;;;;;;;;;;EACF,CAAC;;AAED,SAAgBhC,SAASA,CACvBoC,QAA+D;;;IAE/D,IAAIC,OAAO,GAAG5B,aAAa,EAAE;IAC7B,MAAM6B,OAAO,GAAG,IAAIC,WAAW,EAAE;;MACjC,KAAuC,IAAAnB,EAAA,SAAAoB,UAAA,GAAAlB,aAAA,CAAAc,QAAQ,GAAAK,YAAA,EAAAA,YAAA,SAAAjB,OAAA,CAAAgB,UAAA,CAAAf,IAAA,KAAAC,EAAA,GAAAe,YAAA,CAAAd,IAAA,GAAAD,EAAA,EAAAN,EAAA,SAAE;QAAVQ,EAAA,GAAAa,YAAA,CAAAZ,KAAA;QAAAT,EAAA;QAA5B,MAAM;UAAEc,IAAI;UAAEhB;QAAQ,CAAE,GAAAU,EAAA;QACjC,IAAIM,IAAI,CAAC3B,MAAM,KAAK,CAAC,IAAI8B,OAAO,CAAC3B,IAAI,KAAKC,SAAS,EAAE;UACnD;UACA,YAAAa,OAAA,CAAMa,OAAuB;UAC7BA,OAAO,GAAG5B,aAAa,EAAE;QAC3B,CAAC,MAAM,IAAIS,QAAQ,GAAG,CAAC,EAAE;UACvB;UACA;UACA;UACA,MAAMwB,KAAK,GAAGJ,OAAO,CAACK,MAAM,CAACT,IAAI,CAACC,QAAQ,CAAC,CAAC,EAAEjB,QAAQ,CAAC,CAAC;UACxD,MAAM0B,WAAW,GAAG1B,QAAQ,IAAIgB,IAAI,CAAChB,QAAQ,GAAG,CAAC,CAAC,mCAA0B,CAAC,GAAG,CAAC,CAAC;UAClF,MAAMW,KAAK,GAAGS,OAAO,CAACK,MAAM,CAACT,IAAI,CAACC,QAAQ,CAACS,WAAW,CAAC,CAAC;UAExD,QAAQF,KAAK;YACX,KAAK,MAAM;cACTL,OAAO,CAAC3B,IAAI,GAAG2B,OAAO,CAAC3B,IAAI,GAAG2B,OAAO,CAAC3B,IAAI,GAAG,IAAI,GAAGmB,KAAK,GAAGA,KAAK;cACjE;YACF,KAAK,OAAO;cACVQ,OAAO,CAACzB,KAAK,GAAGiB,KAAK;cACrB;YACF,KAAK,IAAI;cACPQ,OAAO,CAACxB,EAAE,GAAGgB,KAAK;cAClB;YACF,KAAK,OAAO;cAAE;gBACZ,MAAMf,KAAK,GAAG+B,QAAQ,CAAChB,KAAK,EAAE,EAAE,CAAC;gBACjC,IAAI,CAACiB,KAAK,CAAChC,KAAK,CAAC,EAAE;kBACjBuB,OAAO,CAACvB,KAAK,GAAGA,KAAK;gBACvB;gBACA;cACF;UACF;QACF;MACF;;;;;;;;;;;;EACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}