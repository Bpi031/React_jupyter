{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { __asyncGenerator, __await } from \"tslib\";\nexport function createStream(asyncIter, cancel) {\n  const stream = iteratorToStream(asyncIter, cancel);\n  /** TODO: remove these polyfills once all supported runtimes support them */\n  return polyfillStream(stream, cancel);\n}\nfunction polyfillStream(stream, dispose) {\n  makeAsyncIterable(stream);\n  makeAsyncDisposable(stream, dispose);\n  return stream;\n}\nfunction makeAsyncDisposable(webStream, dispose) {\n  var _a;\n  (_a = Symbol.asyncDispose) !== null && _a !== void 0 ? _a : Symbol.asyncDispose = Symbol(\"Symbol.asyncDispose\");\n  if (!webStream[Symbol.asyncDispose]) {\n    webStream[Symbol.asyncDispose] = () => dispose();\n  }\n}\nfunction makeAsyncIterable(webStream) {\n  if (!webStream[Symbol.asyncIterator]) {\n    webStream[Symbol.asyncIterator] = () => toAsyncIterable(webStream);\n  }\n  if (!webStream.values) {\n    webStream.values = () => toAsyncIterable(webStream);\n  }\n}\nfunction iteratorToStream(iterator, cancel) {\n  return new ReadableStream({\n    async pull(controller) {\n      const {\n        value,\n        done\n      } = await iterator.next();\n      if (done) {\n        controller.close();\n      } else {\n        controller.enqueue(value);\n      }\n    },\n    cancel\n  });\n}\nexport function ensureAsyncIterable(stream) {\n  if (isReadableStream(stream)) {\n    makeAsyncIterable(stream);\n    return {\n      cancel: () => stream.cancel(),\n      iterable: stream\n    };\n  } else {\n    return {\n      cancel: async () => {\n        stream.socket.end();\n      },\n      iterable: stream\n    };\n  }\n}\nfunction isReadableStream(body) {\n  return Boolean(body && typeof body.getReader === \"function\" && typeof body.tee === \"function\");\n}\nfunction toAsyncIterable(stream) {\n  return __asyncGenerator(this, arguments, function* toAsyncIterable_1() {\n    const reader = stream.getReader();\n    try {\n      while (true) {\n        const {\n          value,\n          done\n        } = yield __await(reader.read());\n        if (done) {\n          return yield __await(void 0);\n        }\n        yield yield __await(value);\n      }\n    } finally {\n      const cancelPromise = reader.cancel();\n      reader.releaseLock();\n      yield __await(cancelPromise);\n    }\n  });\n}","map":{"version":3,"names":["createStream","asyncIter","cancel","stream","iteratorToStream","polyfillStream","dispose","makeAsyncIterable","makeAsyncDisposable","webStream","_a","Symbol","asyncDispose","asyncIterator","toAsyncIterable","values","iterator","ReadableStream","pull","controller","value","done","next","close","enqueue","ensureAsyncIterable","isReadableStream","iterable","socket","end","body","Boolean","getReader","tee","reader","__await","read","cancelPromise","releaseLock"],"sources":["/workspaces/codespaces-blank/jupyter_react/node_modules/@azure/core-sse/src/utils.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { IncomingMessage } from \"http\";\n\nexport function createStream<T>(\n  asyncIter: AsyncIterableIterator<T>,\n  cancel: () => PromiseLike<void>,\n): ReadableStream<T> & AsyncDisposable & AsyncIterable<T> {\n  const stream = iteratorToStream(asyncIter, cancel);\n  /** TODO: remove these polyfills once all supported runtimes support them */\n  return polyfillStream(stream, cancel);\n}\n\nfunction polyfillStream<T>(\n  stream: ReadableStream<T>,\n  dispose: () => PromiseLike<void>,\n): ReadableStream<T> & AsyncIterable<T> & AsyncDisposable {\n  makeAsyncIterable<T>(stream);\n  makeAsyncDisposable(stream, dispose);\n  return stream;\n}\n\nfunction makeAsyncDisposable<T>(\n  webStream: any,\n  dispose: () => PromiseLike<void>,\n): asserts webStream is ReadableStream<T> & AsyncDisposable {\n  (Symbol.asyncDispose as any) ??= Symbol(\"Symbol.asyncDispose\");\n  if (!webStream[Symbol.asyncDispose]) {\n    webStream[Symbol.asyncDispose] = () => dispose();\n  }\n}\n\nfunction makeAsyncIterable<T>(\n  webStream: any,\n): asserts webStream is ReadableStream<T> & AsyncIterable<T> {\n  if (!webStream[Symbol.asyncIterator]) {\n    webStream[Symbol.asyncIterator] = () => toAsyncIterable(webStream);\n  }\n\n  if (!webStream.values) {\n    webStream.values = () => toAsyncIterable(webStream);\n  }\n}\n\nfunction iteratorToStream<T>(\n  iterator: AsyncIterableIterator<T>,\n  cancel: () => PromiseLike<void>,\n): ReadableStream<T> {\n  return new ReadableStream({\n    async pull(controller) {\n      const { value, done } = await iterator.next();\n      if (done) {\n        controller.close();\n      } else {\n        controller.enqueue(value);\n      }\n    },\n    cancel,\n  });\n}\n\nexport function ensureAsyncIterable(stream: IncomingMessage | ReadableStream<Uint8Array>): {\n  cancel(): Promise<void>;\n  iterable: AsyncIterable<Uint8Array>;\n} {\n  if (isReadableStream(stream)) {\n    makeAsyncIterable<Uint8Array>(stream);\n    return {\n      cancel: () => stream.cancel(),\n      iterable: stream,\n    };\n  } else {\n    return {\n      cancel: async () => {\n        stream.socket.end();\n      },\n      iterable: stream as AsyncIterable<Uint8Array>,\n    };\n  }\n}\n\nfunction isReadableStream(body: unknown): body is ReadableStream {\n  return Boolean(\n    body &&\n      typeof (body as ReadableStream).getReader === \"function\" &&\n      typeof (body as ReadableStream).tee === \"function\",\n  );\n}\n\nasync function* toAsyncIterable<T>(stream: ReadableStream<T>): AsyncIterableIterator<T> {\n  const reader = stream.getReader();\n  try {\n    while (true) {\n      const { value, done } = await reader.read();\n      if (done) {\n        return;\n      }\n      yield value;\n    }\n  } finally {\n    const cancelPromise = reader.cancel();\n    reader.releaseLock();\n    await cancelPromise;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}