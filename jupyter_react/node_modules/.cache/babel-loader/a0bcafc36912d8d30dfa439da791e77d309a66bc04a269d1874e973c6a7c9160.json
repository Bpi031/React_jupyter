{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/**\n * Builds the request url, filling in query and path parameters\n * @param endpoint - base url which can be a template url\n * @param routePath - path to append to the endpoint\n * @param pathParameters - values of the path parameters\n * @param options - request parameters including query parameters\n * @returns a full url with path and query parameters\n */\nexport function buildRequestUrl(endpoint, routePath, pathParameters, options = {}) {\n  if (routePath.startsWith(\"https://\") || routePath.startsWith(\"http://\")) {\n    return routePath;\n  }\n  endpoint = buildBaseUrl(endpoint, options);\n  routePath = buildRoutePath(routePath, pathParameters, options);\n  const requestUrl = appendQueryParams(`${endpoint}/${routePath}`, options);\n  const url = new URL(requestUrl);\n  return url.toString()\n  // Remove double forward slashes\n  .replace(/([^:]\\/)\\/+/g, \"$1\");\n}\nfunction appendQueryParams(url, options = {}) {\n  if (!options.queryParameters) {\n    return url;\n  }\n  let parsedUrl = new URL(url);\n  const queryParams = options.queryParameters;\n  for (const key of Object.keys(queryParams)) {\n    const param = queryParams[key];\n    if (param === undefined || param === null) {\n      continue;\n    }\n    if (!param.toString || typeof param.toString !== \"function\") {\n      throw new Error(`Query parameters must be able to be represented as string, ${key} can't`);\n    }\n    const value = param.toISOString !== undefined ? param.toISOString() : param.toString();\n    parsedUrl.searchParams.append(key, value);\n  }\n  if (options.skipUrlEncoding) {\n    parsedUrl = skipQueryParameterEncoding(parsedUrl);\n  }\n  return parsedUrl.toString();\n}\nfunction skipQueryParameterEncoding(url) {\n  if (!url) {\n    return url;\n  }\n  const searchPieces = [];\n  for (const [name, value] of url.searchParams) {\n    // QUIRK: searchParams.get retrieves the values decoded\n    searchPieces.push(`${name}=${value}`);\n  }\n  // QUIRK: we have to set search manually as searchParams will encode comma when it shouldn't.\n  url.search = searchPieces.length ? `?${searchPieces.join(\"&\")}` : \"\";\n  return url;\n}\nexport function buildBaseUrl(endpoint, options) {\n  var _a;\n  if (!options.pathParameters) {\n    return endpoint;\n  }\n  const pathParams = options.pathParameters;\n  for (const [key, param] of Object.entries(pathParams)) {\n    if (param === undefined || param === null) {\n      throw new Error(`Path parameters ${key} must not be undefined or null`);\n    }\n    if (!param.toString || typeof param.toString !== \"function\") {\n      throw new Error(`Path parameters must be able to be represented as string, ${key} can't`);\n    }\n    let value = param.toISOString !== undefined ? param.toISOString() : String(param);\n    if (!options.skipUrlEncoding) {\n      value = encodeURIComponent(param);\n    }\n    endpoint = (_a = replaceAll(endpoint, `{${key}}`, value)) !== null && _a !== void 0 ? _a : \"\";\n  }\n  return endpoint;\n}\nfunction buildRoutePath(routePath, pathParameters, options = {}) {\n  for (const pathParam of pathParameters) {\n    let value = pathParam;\n    if (!options.skipUrlEncoding) {\n      value = encodeURIComponent(pathParam);\n    }\n    routePath = routePath.replace(/\\{\\w+\\}/, value);\n  }\n  return routePath;\n}\n/**\n * Replace all of the instances of searchValue in value with the provided replaceValue.\n * @param value - The value to search and replace in.\n * @param searchValue - The value to search for in the value argument.\n * @param replaceValue - The value to replace searchValue with in the value argument.\n * @returns The value where each instance of searchValue was replaced with replacedValue.\n */\nexport function replaceAll(value, searchValue, replaceValue) {\n  return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || \"\");\n}","map":{"version":3,"names":["buildRequestUrl","endpoint","routePath","pathParameters","options","startsWith","buildBaseUrl","buildRoutePath","requestUrl","appendQueryParams","url","URL","toString","replace","queryParameters","parsedUrl","queryParams","key","Object","keys","param","undefined","Error","value","toISOString","searchParams","append","skipUrlEncoding","skipQueryParameterEncoding","searchPieces","name","push","search","length","join","pathParams","entries","String","encodeURIComponent","_a","replaceAll","pathParam","searchValue","replaceValue","split"],"sources":["/workspaces/codespaces-blank/jupyter_react/node_modules/@azure-rest/core-client/src/urlHelpers.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { RequestParameters } from \"./common\";\n\n/**\n * Builds the request url, filling in query and path parameters\n * @param endpoint - base url which can be a template url\n * @param routePath - path to append to the endpoint\n * @param pathParameters - values of the path parameters\n * @param options - request parameters including query parameters\n * @returns a full url with path and query parameters\n */\nexport function buildRequestUrl(\n  endpoint: string,\n  routePath: string,\n  pathParameters: string[],\n  options: RequestParameters = {},\n): string {\n  if (routePath.startsWith(\"https://\") || routePath.startsWith(\"http://\")) {\n    return routePath;\n  }\n  endpoint = buildBaseUrl(endpoint, options);\n  routePath = buildRoutePath(routePath, pathParameters, options);\n  const requestUrl = appendQueryParams(`${endpoint}/${routePath}`, options);\n  const url = new URL(requestUrl);\n\n  return (\n    url\n      .toString()\n      // Remove double forward slashes\n      .replace(/([^:]\\/)\\/+/g, \"$1\")\n  );\n}\n\nfunction appendQueryParams(url: string, options: RequestParameters = {}) {\n  if (!options.queryParameters) {\n    return url;\n  }\n  let parsedUrl = new URL(url);\n  const queryParams = options.queryParameters;\n  for (const key of Object.keys(queryParams)) {\n    const param = queryParams[key] as any;\n    if (param === undefined || param === null) {\n      continue;\n    }\n    if (!param.toString || typeof param.toString !== \"function\") {\n      throw new Error(`Query parameters must be able to be represented as string, ${key} can't`);\n    }\n    const value = param.toISOString !== undefined ? param.toISOString() : param.toString();\n    parsedUrl.searchParams.append(key, value);\n  }\n\n  if (options.skipUrlEncoding) {\n    parsedUrl = skipQueryParameterEncoding(parsedUrl);\n  }\n  return parsedUrl.toString();\n}\n\nfunction skipQueryParameterEncoding(url: URL) {\n  if (!url) {\n    return url;\n  }\n  const searchPieces: string[] = [];\n  for (const [name, value] of url.searchParams) {\n    // QUIRK: searchParams.get retrieves the values decoded\n    searchPieces.push(`${name}=${value}`);\n  }\n  // QUIRK: we have to set search manually as searchParams will encode comma when it shouldn't.\n  url.search = searchPieces.length ? `?${searchPieces.join(\"&\")}` : \"\";\n  return url;\n}\n\nexport function buildBaseUrl(endpoint: string, options: RequestParameters): string {\n  if (!options.pathParameters) {\n    return endpoint;\n  }\n  const pathParams = options.pathParameters;\n  for (const [key, param] of Object.entries(pathParams)) {\n    if (param === undefined || param === null) {\n      throw new Error(`Path parameters ${key} must not be undefined or null`);\n    }\n    if (!param.toString || typeof param.toString !== \"function\") {\n      throw new Error(`Path parameters must be able to be represented as string, ${key} can't`);\n    }\n    let value = param.toISOString !== undefined ? param.toISOString() : String(param);\n    if (!options.skipUrlEncoding) {\n      value = encodeURIComponent(param);\n    }\n    endpoint = replaceAll(endpoint, `{${key}}`, value) ?? \"\";\n  }\n  return endpoint;\n}\n\nfunction buildRoutePath(\n  routePath: string,\n  pathParameters: string[],\n  options: RequestParameters = {},\n) {\n  for (const pathParam of pathParameters) {\n    let value = pathParam;\n    if (!options.skipUrlEncoding) {\n      value = encodeURIComponent(pathParam);\n    }\n\n    routePath = routePath.replace(/\\{\\w+\\}/, value);\n  }\n  return routePath;\n}\n\n/**\n * Replace all of the instances of searchValue in value with the provided replaceValue.\n * @param value - The value to search and replace in.\n * @param searchValue - The value to search for in the value argument.\n * @param replaceValue - The value to replace searchValue with in the value argument.\n * @returns The value where each instance of searchValue was replaced with replacedValue.\n */\nexport function replaceAll(\n  value: string | undefined,\n  searchValue: string,\n  replaceValue: string,\n): string | undefined {\n  return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || \"\");\n}\n"],"mappings":"AAAA;AACA;AAIA;;;;;;;;AAQA,OAAM,SAAUA,eAAeA,CAC7BC,QAAgB,EAChBC,SAAiB,EACjBC,cAAwB,EACxBC,OAAA,GAA6B,EAAE;EAE/B,IAAIF,SAAS,CAACG,UAAU,CAAC,UAAU,CAAC,IAAIH,SAAS,CAACG,UAAU,CAAC,SAAS,CAAC,EAAE;IACvE,OAAOH,SAAS;EAClB;EACAD,QAAQ,GAAGK,YAAY,CAACL,QAAQ,EAAEG,OAAO,CAAC;EAC1CF,SAAS,GAAGK,cAAc,CAACL,SAAS,EAAEC,cAAc,EAAEC,OAAO,CAAC;EAC9D,MAAMI,UAAU,GAAGC,iBAAiB,CAAC,GAAGR,QAAQ,IAAIC,SAAS,EAAE,EAAEE,OAAO,CAAC;EACzE,MAAMM,GAAG,GAAG,IAAIC,GAAG,CAACH,UAAU,CAAC;EAE/B,OACEE,GAAG,CACAE,QAAQ;EACT;EAAA,CACCC,OAAO,CAAC,cAAc,EAAE,IAAI,CAAC;AAEpC;AAEA,SAASJ,iBAAiBA,CAACC,GAAW,EAAEN,OAAA,GAA6B,EAAE;EACrE,IAAI,CAACA,OAAO,CAACU,eAAe,EAAE;IAC5B,OAAOJ,GAAG;EACZ;EACA,IAAIK,SAAS,GAAG,IAAIJ,GAAG,CAACD,GAAG,CAAC;EAC5B,MAAMM,WAAW,GAAGZ,OAAO,CAACU,eAAe;EAC3C,KAAK,MAAMG,GAAG,IAAIC,MAAM,CAACC,IAAI,CAACH,WAAW,CAAC,EAAE;IAC1C,MAAMI,KAAK,GAAGJ,WAAW,CAACC,GAAG,CAAQ;IACrC,IAAIG,KAAK,KAAKC,SAAS,IAAID,KAAK,KAAK,IAAI,EAAE;MACzC;IACF;IACA,IAAI,CAACA,KAAK,CAACR,QAAQ,IAAI,OAAOQ,KAAK,CAACR,QAAQ,KAAK,UAAU,EAAE;MAC3D,MAAM,IAAIU,KAAK,CAAC,8DAA8DL,GAAG,QAAQ,CAAC;IAC5F;IACA,MAAMM,KAAK,GAAGH,KAAK,CAACI,WAAW,KAAKH,SAAS,GAAGD,KAAK,CAACI,WAAW,EAAE,GAAGJ,KAAK,CAACR,QAAQ,EAAE;IACtFG,SAAS,CAACU,YAAY,CAACC,MAAM,CAACT,GAAG,EAAEM,KAAK,CAAC;EAC3C;EAEA,IAAInB,OAAO,CAACuB,eAAe,EAAE;IAC3BZ,SAAS,GAAGa,0BAA0B,CAACb,SAAS,CAAC;EACnD;EACA,OAAOA,SAAS,CAACH,QAAQ,EAAE;AAC7B;AAEA,SAASgB,0BAA0BA,CAAClB,GAAQ;EAC1C,IAAI,CAACA,GAAG,EAAE;IACR,OAAOA,GAAG;EACZ;EACA,MAAMmB,YAAY,GAAa,EAAE;EACjC,KAAK,MAAM,CAACC,IAAI,EAAEP,KAAK,CAAC,IAAIb,GAAG,CAACe,YAAY,EAAE;IAC5C;IACAI,YAAY,CAACE,IAAI,CAAC,GAAGD,IAAI,IAAIP,KAAK,EAAE,CAAC;EACvC;EACA;EACAb,GAAG,CAACsB,MAAM,GAAGH,YAAY,CAACI,MAAM,GAAG,IAAIJ,YAAY,CAACK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,EAAE;EACpE,OAAOxB,GAAG;AACZ;AAEA,OAAM,SAAUJ,YAAYA,CAACL,QAAgB,EAAEG,OAA0B;;EACvE,IAAI,CAACA,OAAO,CAACD,cAAc,EAAE;IAC3B,OAAOF,QAAQ;EACjB;EACA,MAAMkC,UAAU,GAAG/B,OAAO,CAACD,cAAc;EACzC,KAAK,MAAM,CAACc,GAAG,EAAEG,KAAK,CAAC,IAAIF,MAAM,CAACkB,OAAO,CAACD,UAAU,CAAC,EAAE;IACrD,IAAIf,KAAK,KAAKC,SAAS,IAAID,KAAK,KAAK,IAAI,EAAE;MACzC,MAAM,IAAIE,KAAK,CAAC,mBAAmBL,GAAG,gCAAgC,CAAC;IACzE;IACA,IAAI,CAACG,KAAK,CAACR,QAAQ,IAAI,OAAOQ,KAAK,CAACR,QAAQ,KAAK,UAAU,EAAE;MAC3D,MAAM,IAAIU,KAAK,CAAC,6DAA6DL,GAAG,QAAQ,CAAC;IAC3F;IACA,IAAIM,KAAK,GAAGH,KAAK,CAACI,WAAW,KAAKH,SAAS,GAAGD,KAAK,CAACI,WAAW,EAAE,GAAGa,MAAM,CAACjB,KAAK,CAAC;IACjF,IAAI,CAAChB,OAAO,CAACuB,eAAe,EAAE;MAC5BJ,KAAK,GAAGe,kBAAkB,CAAClB,KAAK,CAAC;IACnC;IACAnB,QAAQ,GAAG,CAAAsC,EAAA,GAAAC,UAAU,CAACvC,QAAQ,EAAE,IAAIgB,GAAG,GAAG,EAAEM,KAAK,CAAC,cAAAgB,EAAA,cAAAA,EAAA,GAAI,EAAE;EAC1D;EACA,OAAOtC,QAAQ;AACjB;AAEA,SAASM,cAAcA,CACrBL,SAAiB,EACjBC,cAAwB,EACxBC,OAAA,GAA6B,EAAE;EAE/B,KAAK,MAAMqC,SAAS,IAAItC,cAAc,EAAE;IACtC,IAAIoB,KAAK,GAAGkB,SAAS;IACrB,IAAI,CAACrC,OAAO,CAACuB,eAAe,EAAE;MAC5BJ,KAAK,GAAGe,kBAAkB,CAACG,SAAS,CAAC;IACvC;IAEAvC,SAAS,GAAGA,SAAS,CAACW,OAAO,CAAC,SAAS,EAAEU,KAAK,CAAC;EACjD;EACA,OAAOrB,SAAS;AAClB;AAEA;;;;;;;AAOA,OAAM,SAAUsC,UAAUA,CACxBjB,KAAyB,EACzBmB,WAAmB,EACnBC,YAAoB;EAEpB,OAAO,CAACpB,KAAK,IAAI,CAACmB,WAAW,GAAGnB,KAAK,GAAGA,KAAK,CAACqB,KAAK,CAACF,WAAW,CAAC,CAACR,IAAI,CAACS,YAAY,IAAI,EAAE,CAAC;AAC3F","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}