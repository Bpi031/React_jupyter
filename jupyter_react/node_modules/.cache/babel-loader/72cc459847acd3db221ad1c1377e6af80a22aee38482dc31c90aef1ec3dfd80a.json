{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { RestError, createFile, createHttpHeaders, createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { getCachedDefaultHttpsClient } from \"./clientHelpers\";\nimport { isReadableStream } from \"./helpers/isReadableStream\";\n/**\n * Helper function to send request used by the client\n * @param method - method to use to send the request\n * @param url - url to send the request to\n * @param pipeline - pipeline with the policies to run when sending the request\n * @param options - request options\n * @param customHttpClient - a custom HttpClient to use when making the request\n * @returns returns and HttpResponse\n */\nexport async function sendRequest(method, url, pipeline, options = {}, customHttpClient) {\n  var _a;\n  const httpClient = customHttpClient !== null && customHttpClient !== void 0 ? customHttpClient : getCachedDefaultHttpsClient();\n  const request = buildPipelineRequest(method, url, options);\n  const response = await pipeline.sendRequest(httpClient, request);\n  const headers = response.headers.toJSON();\n  const stream = (_a = response.readableStreamBody) !== null && _a !== void 0 ? _a : response.browserStreamBody;\n  const parsedBody = options.responseAsStream || stream !== undefined ? undefined : getResponseBody(response);\n  const body = stream !== null && stream !== void 0 ? stream : parsedBody;\n  if (options === null || options === void 0 ? void 0 : options.onResponse) {\n    options.onResponse(Object.assign(Object.assign({}, response), {\n      request,\n      rawHeaders: headers,\n      parsedBody\n    }));\n  }\n  return {\n    request,\n    headers,\n    status: `${response.status}`,\n    body\n  };\n}\n/**\n * Function to determine the content-type of a body\n * this is used if an explicit content-type is not provided\n * @param body - body in the request\n * @returns returns the content-type\n */\nfunction getContentType(body) {\n  if (ArrayBuffer.isView(body)) {\n    return \"application/octet-stream\";\n  }\n  // By default return json\n  return \"application/json; charset=UTF-8\";\n}\nfunction buildPipelineRequest(method, url, options = {}) {\n  var _a, _b;\n  const {\n    body,\n    formData\n  } = getRequestBody(options.body, options.contentType);\n  const hasContent = body !== undefined || formData !== undefined;\n  const headers = createHttpHeaders(Object.assign(Object.assign(Object.assign({}, options.headers ? options.headers : {}), {\n    accept: (_a = options.accept) !== null && _a !== void 0 ? _a : \"application/json\"\n  }), hasContent && {\n    \"content-type\": (_b = options.contentType) !== null && _b !== void 0 ? _b : getContentType(options.body)\n  }));\n  return createPipelineRequest({\n    url,\n    method,\n    body,\n    formData,\n    headers,\n    allowInsecureConnection: options.allowInsecureConnection,\n    tracingOptions: options.tracingOptions,\n    abortSignal: options.abortSignal,\n    onUploadProgress: options.onUploadProgress,\n    onDownloadProgress: options.onDownloadProgress,\n    timeout: options.timeout,\n    enableBrowserStreams: true,\n    streamResponseStatusCodes: options.responseAsStream ? new Set([Number.POSITIVE_INFINITY]) : undefined\n  });\n}\n/**\n * Prepares the body before sending the request\n */\nfunction getRequestBody(body, contentType = \"\") {\n  if (body === undefined) {\n    return {\n      body: undefined\n    };\n  }\n  if (isReadableStream(body)) {\n    return {\n      body\n    };\n  }\n  if (!contentType && typeof body === \"string\") {\n    return {\n      body\n    };\n  }\n  const firstType = contentType.split(\";\")[0];\n  if (firstType === \"application/json\") {\n    return {\n      body: JSON.stringify(body)\n    };\n  }\n  if (ArrayBuffer.isView(body)) {\n    return {\n      body: body instanceof Uint8Array ? body : JSON.stringify(body)\n    };\n  }\n  switch (firstType) {\n    case \"multipart/form-data\":\n      return isRLCFormDataInput(body) ? {\n        formData: processFormData(body)\n      } : {\n        body: JSON.stringify(body)\n      };\n    case \"text/plain\":\n      return {\n        body: String(body)\n      };\n    default:\n      if (typeof body === \"string\") {\n        return {\n          body\n        };\n      }\n      return {\n        body: JSON.stringify(body)\n      };\n  }\n}\nfunction isRLCFormDataValue(value) {\n  return typeof value === \"string\" || value instanceof Uint8Array ||\n  // We don't do `instanceof Blob` since we should also accept polyfills of e.g. File in Node.\n  typeof value.stream === \"function\";\n}\nfunction isRLCFormDataInput(body) {\n  return body !== undefined && body instanceof Object && Object.values(body).every(value => isRLCFormDataValue(value) || Array.isArray(value) && value.every(isRLCFormDataValue));\n}\nfunction processFormDataValue(value) {\n  return value instanceof Uint8Array ? createFile(value, \"blob\") : value;\n}\n/**\n * Checks if binary data is in Uint8Array format, if so wrap it in a Blob\n * to send over the wire\n */\nfunction processFormData(formData) {\n  const processedFormData = {};\n  for (const element in formData) {\n    const value = formData[element];\n    processedFormData[element] = Array.isArray(value) ? value.map(processFormDataValue) : processFormDataValue(value);\n  }\n  return processedFormData;\n}\n/**\n * Prepares the response body\n */\nfunction getResponseBody(response) {\n  var _a, _b;\n  // Set the default response type\n  const contentType = (_a = response.headers.get(\"content-type\")) !== null && _a !== void 0 ? _a : \"\";\n  const firstType = contentType.split(\";\")[0];\n  const bodyToParse = (_b = response.bodyAsText) !== null && _b !== void 0 ? _b : \"\";\n  if (firstType === \"text/plain\") {\n    return String(bodyToParse);\n  }\n  // Default to \"application/json\" and fallback to string;\n  try {\n    return bodyToParse ? JSON.parse(bodyToParse) : undefined;\n  } catch (error) {\n    // If we were supposed to get a JSON object and failed to\n    // parse, throw a parse error\n    if (firstType === \"application/json\") {\n      throw createParseError(response, error);\n    }\n    // We are not sure how to handle the response so we return it as\n    // plain text.\n    return String(bodyToParse);\n  }\n}\nfunction createParseError(response, err) {\n  var _a;\n  const msg = `Error \"${err}\" occurred while parsing the response body - ${response.bodyAsText}.`;\n  const errCode = (_a = err.code) !== null && _a !== void 0 ? _a : RestError.PARSE_ERROR;\n  return new RestError(msg, {\n    code: errCode,\n    statusCode: response.status,\n    request: response.request,\n    response: response\n  });\n}","map":{"version":3,"names":["RestError","createFile","createHttpHeaders","createPipelineRequest","getCachedDefaultHttpsClient","isReadableStream","sendRequest","method","url","pipeline","options","customHttpClient","httpClient","request","buildPipelineRequest","response","headers","toJSON","stream","_a","readableStreamBody","browserStreamBody","parsedBody","responseAsStream","undefined","getResponseBody","body","onResponse","Object","assign","rawHeaders","status","getContentType","ArrayBuffer","isView","formData","getRequestBody","contentType","hasContent","accept","_b","allowInsecureConnection","tracingOptions","abortSignal","onUploadProgress","onDownloadProgress","timeout","enableBrowserStreams","streamResponseStatusCodes","Set","Number","POSITIVE_INFINITY","firstType","split","JSON","stringify","Uint8Array","isRLCFormDataInput","processFormData","String","isRLCFormDataValue","value","values","every","Array","isArray","processFormDataValue","processedFormData","element","map","get","bodyToParse","bodyAsText","parse","error","createParseError","err","msg","errCode","code","PARSE_ERROR","statusCode"],"sources":["/workspaces/codespaces-blank/jupyter_react/node_modules/@azure-rest/core-client/src/sendRequest.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  FormDataMap,\n  FormDataValue,\n  HttpClient,\n  HttpMethods,\n  Pipeline,\n  PipelineRequest,\n  PipelineResponse,\n  RequestBodyType,\n  RestError,\n  createFile,\n  createHttpHeaders,\n  createPipelineRequest,\n} from \"@azure/core-rest-pipeline\";\nimport { getCachedDefaultHttpsClient } from \"./clientHelpers\";\nimport { isReadableStream } from \"./helpers/isReadableStream\";\nimport { HttpResponse, RequestParameters } from \"./common\";\n\n/**\n * Helper function to send request used by the client\n * @param method - method to use to send the request\n * @param url - url to send the request to\n * @param pipeline - pipeline with the policies to run when sending the request\n * @param options - request options\n * @param customHttpClient - a custom HttpClient to use when making the request\n * @returns returns and HttpResponse\n */\nexport async function sendRequest(\n  method: HttpMethods,\n  url: string,\n  pipeline: Pipeline,\n  options: InternalRequestParameters = {},\n  customHttpClient?: HttpClient,\n): Promise<HttpResponse> {\n  const httpClient = customHttpClient ?? getCachedDefaultHttpsClient();\n  const request = buildPipelineRequest(method, url, options);\n  const response = await pipeline.sendRequest(httpClient, request);\n  const headers = response.headers.toJSON();\n  const stream = response.readableStreamBody ?? response.browserStreamBody;\n  const parsedBody =\n    options.responseAsStream || stream !== undefined ? undefined : getResponseBody(response);\n  const body = stream ?? parsedBody;\n\n  if (options?.onResponse) {\n    options.onResponse({ ...response, request, rawHeaders: headers, parsedBody });\n  }\n\n  return {\n    request,\n    headers,\n    status: `${response.status}`,\n    body,\n  };\n}\n\n/**\n * Function to determine the content-type of a body\n * this is used if an explicit content-type is not provided\n * @param body - body in the request\n * @returns returns the content-type\n */\nfunction getContentType(body: any): string {\n  if (ArrayBuffer.isView(body)) {\n    return \"application/octet-stream\";\n  }\n\n  // By default return json\n  return \"application/json; charset=UTF-8\";\n}\n\nexport interface InternalRequestParameters extends RequestParameters {\n  responseAsStream?: boolean;\n}\n\nfunction buildPipelineRequest(\n  method: HttpMethods,\n  url: string,\n  options: InternalRequestParameters = {},\n): PipelineRequest {\n  const { body, formData } = getRequestBody(options.body, options.contentType);\n  const hasContent = body !== undefined || formData !== undefined;\n\n  const headers = createHttpHeaders({\n    ...(options.headers ? options.headers : {}),\n    accept: options.accept ?? \"application/json\",\n    ...(hasContent && {\n      \"content-type\": options.contentType ?? getContentType(options.body),\n    }),\n  });\n\n  return createPipelineRequest({\n    url,\n    method,\n    body,\n    formData,\n    headers,\n    allowInsecureConnection: options.allowInsecureConnection,\n    tracingOptions: options.tracingOptions,\n    abortSignal: options.abortSignal,\n    onUploadProgress: options.onUploadProgress,\n    onDownloadProgress: options.onDownloadProgress,\n    timeout: options.timeout,\n    enableBrowserStreams: true,\n    streamResponseStatusCodes: options.responseAsStream\n      ? new Set([Number.POSITIVE_INFINITY])\n      : undefined,\n  });\n}\n\ninterface RequestBody {\n  body?: RequestBodyType;\n  formData?: FormDataMap;\n}\n\n/**\n * Prepares the body before sending the request\n */\nfunction getRequestBody(body?: unknown, contentType: string = \"\"): RequestBody {\n  if (body === undefined) {\n    return { body: undefined };\n  }\n\n  if (isReadableStream(body)) {\n    return { body };\n  }\n\n  if (!contentType && typeof body === \"string\") {\n    return { body };\n  }\n\n  const firstType = contentType.split(\";\")[0];\n\n  if (firstType === \"application/json\") {\n    return { body: JSON.stringify(body) };\n  }\n\n  if (ArrayBuffer.isView(body)) {\n    return { body: body instanceof Uint8Array ? body : JSON.stringify(body) };\n  }\n\n  switch (firstType) {\n    case \"multipart/form-data\":\n      return isRLCFormDataInput(body)\n        ? { formData: processFormData(body) }\n        : { body: JSON.stringify(body) };\n    case \"text/plain\":\n      return { body: String(body) };\n    default:\n      if (typeof body === \"string\") {\n        return { body };\n      }\n      return { body: JSON.stringify(body) };\n  }\n}\n\n/**\n * Union of possible input types for multipart/form-data values that are accepted by RLCs.\n * This extends the default FormDataValue type to include Uint8Array, which is accepted as an input by RLCs.\n */\ntype RLCFormDataValue = FormDataValue | Uint8Array;\n\n/**\n * Input shape for a form data body type as generated by an RLC\n */\ntype RLCFormDataInput = Record<string, RLCFormDataValue | RLCFormDataValue[]>;\n\nfunction isRLCFormDataValue(value: unknown): value is RLCFormDataValue {\n  return (\n    typeof value === \"string\" ||\n    value instanceof Uint8Array ||\n    // We don't do `instanceof Blob` since we should also accept polyfills of e.g. File in Node.\n    typeof (value as Blob).stream === \"function\"\n  );\n}\n\nfunction isRLCFormDataInput(body: unknown): body is RLCFormDataInput {\n  return (\n    body !== undefined &&\n    body instanceof Object &&\n    Object.values(body).every(\n      (value) =>\n        isRLCFormDataValue(value) || (Array.isArray(value) && value.every(isRLCFormDataValue)),\n    )\n  );\n}\n\nfunction processFormDataValue(value: RLCFormDataValue): FormDataValue {\n  return value instanceof Uint8Array ? createFile(value, \"blob\") : value;\n}\n\n/**\n * Checks if binary data is in Uint8Array format, if so wrap it in a Blob\n * to send over the wire\n */\nfunction processFormData(formData: RLCFormDataInput): FormDataMap {\n  const processedFormData: FormDataMap = {};\n\n  for (const element in formData) {\n    const value = formData[element];\n\n    processedFormData[element] = Array.isArray(value)\n      ? value.map(processFormDataValue)\n      : processFormDataValue(value);\n  }\n\n  return processedFormData;\n}\n\n/**\n * Prepares the response body\n */\nfunction getResponseBody(response: PipelineResponse): RequestBodyType | undefined {\n  // Set the default response type\n  const contentType = response.headers.get(\"content-type\") ?? \"\";\n  const firstType = contentType.split(\";\")[0];\n  const bodyToParse = response.bodyAsText ?? \"\";\n\n  if (firstType === \"text/plain\") {\n    return String(bodyToParse);\n  }\n  // Default to \"application/json\" and fallback to string;\n  try {\n    return bodyToParse ? JSON.parse(bodyToParse) : undefined;\n  } catch (error: any) {\n    // If we were supposed to get a JSON object and failed to\n    // parse, throw a parse error\n    if (firstType === \"application/json\") {\n      throw createParseError(response, error);\n    }\n\n    // We are not sure how to handle the response so we return it as\n    // plain text.\n    return String(bodyToParse);\n  }\n}\n\nfunction createParseError(response: PipelineResponse, err: any): RestError {\n  const msg = `Error \"${err}\" occurred while parsing the response body - ${response.bodyAsText}.`;\n  const errCode = err.code ?? RestError.PARSE_ERROR;\n  return new RestError(msg, {\n    code: errCode,\n    statusCode: response.status,\n    request: response.request,\n    response: response,\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}