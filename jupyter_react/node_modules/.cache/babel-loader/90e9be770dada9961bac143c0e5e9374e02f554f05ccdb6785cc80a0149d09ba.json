{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nexport function wrapError(f, message) {\n  try {\n    const result = f();\n    return result;\n  } catch (cause) {\n    throw new Error(`${message}: ${cause}`, {\n      cause\n    });\n  }\n}\nexport function camelCaseKeys(obj) {\n  if (typeof obj !== \"object\" || !obj) return obj;\n  if (Array.isArray(obj)) {\n    return obj.map(v => camelCaseKeys(v));\n  } else {\n    for (const key of Object.keys(obj)) {\n      const value = obj[key];\n      const newKey = tocamelCase(key);\n      if (newKey !== key) {\n        delete obj[key];\n      }\n      obj[newKey] = typeof obj[newKey] === \"object\" ? camelCaseKeys(value) : value;\n    }\n    return obj;\n  }\n}\nexport function snakeCaseKeys(obj) {\n  if (typeof obj !== \"object\" || !obj) return obj;\n  if (Array.isArray(obj)) {\n    return obj.map(v => snakeCaseKeys(v));\n  } else {\n    for (const key of Object.keys(obj)) {\n      const value = obj[key];\n      const newKey = toSnakeCase(key);\n      if (newKey !== key) {\n        delete obj[key];\n      }\n      obj[newKey] = typeof obj[newKey] === \"object\" ? snakeCaseKeys(value) : value;\n    }\n    return obj;\n  }\n}\nfunction tocamelCase(str) {\n  return str.toLowerCase().replace(/([_][a-z])/g, group => group.toUpperCase().replace(\"_\", \"\"));\n}\nfunction toSnakeCase(str) {\n  return str.replace(/([A-Z])/g, group => `_${group.toLowerCase()}`).replace(/^_/, \"\");\n}","map":{"version":3,"names":["wrapError","f","message","result","cause","Error","camelCaseKeys","obj","Array","isArray","map","v","key","Object","keys","value","newKey","tocamelCase","snakeCaseKeys","toSnakeCase","str","toLowerCase","replace","group","toUpperCase"],"sources":["/workspaces/codespaces-blank/jupyter_react/node_modules/@azure/openai/src/api/util.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * THIS IS AN AUTO-GENERATED FILE - DO NOT EDIT!\n *\n * Any changes you make here may be lost.\n *\n * If you need to make changes, please do so in the original source file, \\{project-root\\}/sources/custom\n */\n\ntype CamelCase<S extends string> = S extends `${infer P1}_${infer P2}`\n  ? `${Lowercase<P1>}${Capitalize<CamelCase<P2>>}`\n  : Lowercase<S>;\ntype SnakeCase<S extends string> = S extends `${infer T}${infer U}`\n  ? `${T extends Capitalize<T> ? \"_\" : \"\"}${Lowercase<T>}${SnakeCase<U>}`\n  : S;\n\ntype MapCamelCaseKeysOverCollections<T> =\n  T extends Array<infer X> ? Array<MapCamelCaseKeysOverCollections<X>> : CamelCaseKeys<T>;\ntype MapSnakeCaseKeysOverCollections<T> =\n  T extends Array<infer X>\n    ? Array<MapSnakeCaseKeysOverCollections<X>>\n    : // : T extends (infer X | infer Y)\n      // ? MapSnakeCaseKeysOverCollections<X> | MapSnakeCaseKeysOverCollections<Y>\n      SnakeCaseKeys<T>;\ntype CamelCaseKeys<T> = {\n  [K in keyof T as CamelCase<K & string>]: MapCamelCaseKeysOverCollections<T[K]>;\n};\nexport type SnakeCaseKeys<T> = {\n  [K in keyof T as SnakeCase<K & string>]: MapSnakeCaseKeysOverCollections<T[K]>;\n};\n\nexport function wrapError<T>(f: () => T, message: string): T {\n  try {\n    const result = f();\n    return result;\n  } catch (cause) {\n    throw new Error(`${message}: ${cause}`, { cause });\n  }\n}\n\nexport function camelCaseKeys<O extends Record<string, any>>(obj: O): CamelCaseKeys<O> {\n  if (typeof obj !== \"object\" || !obj) return obj;\n  if (Array.isArray(obj)) {\n    return obj.map((v) =>\n      camelCaseKeys<O extends Array<infer X> ? (X extends Record<string, any> ? X : never) : never>(\n        v,\n      ),\n    ) as CamelCaseKeys<O>;\n  } else {\n    for (const key of Object.keys(obj)) {\n      const value = obj[key];\n      const newKey = tocamelCase(key);\n      if (newKey !== key) {\n        delete obj[key];\n      }\n      (obj[newKey] as Record<string, any>) =\n        typeof obj[newKey] === \"object\" ? camelCaseKeys(value) : value;\n    }\n    return obj;\n  }\n}\n\nexport function snakeCaseKeys<O extends Record<string, any>>(obj: O): SnakeCaseKeys<O> {\n  if (typeof obj !== \"object\" || !obj) return obj;\n  if (Array.isArray(obj)) {\n    return obj.map((v) =>\n      snakeCaseKeys<O extends Array<infer X> ? (X extends Record<string, any> ? X : never) : never>(\n        v,\n      ),\n    ) as SnakeCaseKeys<O>;\n  } else {\n    for (const key of Object.keys(obj)) {\n      const value = obj[key];\n      const newKey = toSnakeCase(key);\n      if (newKey !== key) {\n        delete obj[key];\n      }\n      (obj[newKey] as Record<string, any>) =\n        typeof obj[newKey] === \"object\" ? snakeCaseKeys(value) : value;\n    }\n    return obj;\n  }\n}\n\nfunction tocamelCase<P extends string>(str: P): CamelCase<P> {\n  return str\n    .toLowerCase()\n    .replace(/([_][a-z])/g, (group) => group.toUpperCase().replace(\"_\", \"\")) as CamelCase<P>;\n}\n\nfunction toSnakeCase<P extends string>(str: P): SnakeCase<P> {\n  return str\n    .replace(/([A-Z])/g, (group) => `_${group.toLowerCase()}`)\n    .replace(/^_/, \"\") as SnakeCase<P>;\n}\n"],"mappings":"AAAA;AACA;AAgCA,OAAM,SAAUA,SAASA,CAAIC,CAAU,EAAEC,OAAe;EACtD,IAAI;IACF,MAAMC,MAAM,GAAGF,CAAC,EAAE;IAClB,OAAOE,MAAM;EACf,CAAC,CAAC,OAAOC,KAAK,EAAE;IACd,MAAM,IAAIC,KAAK,CAAC,GAAGH,OAAO,KAAKE,KAAK,EAAE,EAAE;MAAEA;IAAK,CAAE,CAAC;EACpD;AACF;AAEA,OAAM,SAAUE,aAAaA,CAAgCC,GAAM;EACjE,IAAI,OAAOA,GAAG,KAAK,QAAQ,IAAI,CAACA,GAAG,EAAE,OAAOA,GAAG;EAC/C,IAAIC,KAAK,CAACC,OAAO,CAACF,GAAG,CAAC,EAAE;IACtB,OAAOA,GAAG,CAACG,GAAG,CAAEC,CAAC,IACfL,aAAa,CACXK,CAAC,CACF,CACkB;EACvB,CAAC,MAAM;IACL,KAAK,MAAMC,GAAG,IAAIC,MAAM,CAACC,IAAI,CAACP,GAAG,CAAC,EAAE;MAClC,MAAMQ,KAAK,GAAGR,GAAG,CAACK,GAAG,CAAC;MACtB,MAAMI,MAAM,GAAGC,WAAW,CAACL,GAAG,CAAC;MAC/B,IAAII,MAAM,KAAKJ,GAAG,EAAE;QAClB,OAAOL,GAAG,CAACK,GAAG,CAAC;MACjB;MACCL,GAAG,CAACS,MAAM,CAAyB,GAClC,OAAOT,GAAG,CAACS,MAAM,CAAC,KAAK,QAAQ,GAAGV,aAAa,CAACS,KAAK,CAAC,GAAGA,KAAK;IAClE;IACA,OAAOR,GAAG;EACZ;AACF;AAEA,OAAM,SAAUW,aAAaA,CAAgCX,GAAM;EACjE,IAAI,OAAOA,GAAG,KAAK,QAAQ,IAAI,CAACA,GAAG,EAAE,OAAOA,GAAG;EAC/C,IAAIC,KAAK,CAACC,OAAO,CAACF,GAAG,CAAC,EAAE;IACtB,OAAOA,GAAG,CAACG,GAAG,CAAEC,CAAC,IACfO,aAAa,CACXP,CAAC,CACF,CACkB;EACvB,CAAC,MAAM;IACL,KAAK,MAAMC,GAAG,IAAIC,MAAM,CAACC,IAAI,CAACP,GAAG,CAAC,EAAE;MAClC,MAAMQ,KAAK,GAAGR,GAAG,CAACK,GAAG,CAAC;MACtB,MAAMI,MAAM,GAAGG,WAAW,CAACP,GAAG,CAAC;MAC/B,IAAII,MAAM,KAAKJ,GAAG,EAAE;QAClB,OAAOL,GAAG,CAACK,GAAG,CAAC;MACjB;MACCL,GAAG,CAACS,MAAM,CAAyB,GAClC,OAAOT,GAAG,CAACS,MAAM,CAAC,KAAK,QAAQ,GAAGE,aAAa,CAACH,KAAK,CAAC,GAAGA,KAAK;IAClE;IACA,OAAOR,GAAG;EACZ;AACF;AAEA,SAASU,WAAWA,CAAmBG,GAAM;EAC3C,OAAOA,GAAG,CACPC,WAAW,EAAE,CACbC,OAAO,CAAC,aAAa,EAAGC,KAAK,IAAKA,KAAK,CAACC,WAAW,EAAE,CAACF,OAAO,CAAC,GAAG,EAAE,EAAE,CAAC,CAAiB;AAC5F;AAEA,SAASH,WAAWA,CAAmBC,GAAM;EAC3C,OAAOA,GAAG,CACPE,OAAO,CAAC,UAAU,EAAGC,KAAK,IAAK,IAAIA,KAAK,CAACF,WAAW,EAAE,EAAE,CAAC,CACzDC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAiB;AACtC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}