{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { __rest } from \"tslib\";\n/**\n * THIS IS AN AUTO-GENERATED FILE - DO NOT EDIT!\n *\n * Any changes you make here may be lost.\n *\n * If you need to make changes, please do so in the original source file, \\{project-root\\}/sources/custom\n */\nimport { operationOptionsToRequestParameters } from \"@azure-rest/core-client\";\nimport { createFile } from \"@azure/core-rest-pipeline\";\nimport { uint8ArrayToString } from \"@azure/core-util\";\nimport { isUnexpected } from \"../../../rest/index.js\";\nimport { getOaiSSEs } from \"../../oaiSse.js\";\nimport { camelCaseKeys, snakeCaseKeys } from \"../../util.js\";\nimport { getChatCompletionsResult, getCompletionsResult } from \"./deserializers.js\";\nexport function _getAudioTranscriptionAsPlainTextSend(context, deploymentId, body, options = {\n  requestOptions: {}\n}) {\n  return context.path(\"/deployments/{deploymentId}/audio/transcriptions\", deploymentId).post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), {\n    body: {\n      file: uint8ArrayToString(body[\"file\"], \"base64\"),\n      filename: body[\"filename\"],\n      response_format: body[\"responseFormat\"],\n      language: body[\"language\"],\n      prompt: body[\"prompt\"],\n      temperature: body[\"temperature\"],\n      model: body[\"model\"]\n    }\n  }));\n}\nexport async function _getAudioTranscriptionAsPlainTextDeserialize(result) {\n  if (isUnexpected(result)) {\n    throw result.body;\n  }\n  return result.body;\n}\n/**\n * Gets transcribed text and associated metadata from provided spoken audio data. Audio will be transcribed in the\n * written language corresponding to the language it was spoken in.\n */\nexport async function getAudioTranscriptionAsPlainText(context, deploymentId, body, options = {\n  requestOptions: {}\n}) {\n  const result = await _getAudioTranscriptionAsPlainTextSend(context, deploymentId, body, options);\n  return _getAudioTranscriptionAsPlainTextDeserialize(result);\n}\nexport function _getAudioTranscriptionAsResponseObjectSend(context, deploymentId, body, options = {\n  requestOptions: {}\n}) {\n  var _a;\n  return context.path(\"/deployments/{deploymentId}/audio/transcriptions\", deploymentId).post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), {\n    contentType: (_a = options.contentType) !== null && _a !== void 0 ? _a : \"multipart/form-data\",\n    body: {\n      file: uint8ArrayToString(body[\"file\"], \"base64\"),\n      filename: body[\"filename\"],\n      response_format: body[\"responseFormat\"],\n      language: body[\"language\"],\n      prompt: body[\"prompt\"],\n      temperature: body[\"temperature\"],\n      model: body[\"model\"]\n    }\n  }));\n}\nexport async function _getAudioTranscriptionAsResponseObjectDeserialize(result) {\n  if (isUnexpected(result)) {\n    throw result.body;\n  }\n  return {\n    text: result.body[\"text\"],\n    task: result.body[\"task\"],\n    language: result.body[\"language\"],\n    duration: result.body[\"duration\"],\n    segments: !result.body[\"segments\"] ? result.body[\"segments\"] : result.body[\"segments\"].map(p => ({\n      id: p[\"id\"],\n      start: p[\"start\"],\n      end: p[\"end\"],\n      text: p[\"text\"],\n      temperature: p[\"temperature\"],\n      avgLogprob: p[\"avg_logprob\"],\n      compressionRatio: p[\"compression_ratio\"],\n      noSpeechProb: p[\"no_speech_prob\"],\n      tokens: p[\"tokens\"],\n      seek: p[\"seek\"]\n    }))\n  };\n}\n/**\n * Gets transcribed text and associated metadata from provided spoken audio data. Audio will be transcribed in the\n * written language corresponding to the language it was spoken in.\n */\nexport async function getAudioTranscriptionAsResponseObject(context, deploymentId, body, options = {\n  requestOptions: {}\n}) {\n  const result = await _getAudioTranscriptionAsResponseObjectSend(context, deploymentId, body, options);\n  return _getAudioTranscriptionAsResponseObjectDeserialize(result);\n}\nexport function _getAudioTranslationAsPlainTextSend(context, deploymentId, body, options = {\n  requestOptions: {}\n}) {\n  return context.path(\"/deployments/{deploymentId}/audio/translations\", deploymentId).post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), {\n    body: {\n      file: uint8ArrayToString(body[\"file\"], \"base64\"),\n      filename: body[\"filename\"],\n      response_format: body[\"responseFormat\"],\n      prompt: body[\"prompt\"],\n      temperature: body[\"temperature\"],\n      model: body[\"model\"]\n    }\n  }));\n}\nexport async function _getAudioTranslationAsPlainTextDeserialize(result) {\n  if (isUnexpected(result)) {\n    throw result.body;\n  }\n  return result.body;\n}\n/** Gets English language transcribed text and associated metadata from provided spoken audio data. */\nexport async function getAudioTranslationAsPlainText(context, deploymentId, body, options = {\n  requestOptions: {}\n}) {\n  const result = await _getAudioTranslationAsPlainTextSend(context, deploymentId, body, options);\n  return _getAudioTranslationAsPlainTextDeserialize(result);\n}\nexport function _getAudioTranslationAsResponseObjectSend(context, deploymentId, body, options = {\n  requestOptions: {}\n}) {\n  var _a;\n  return context.path(\"/deployments/{deploymentId}/audio/translations\", deploymentId).post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), {\n    contentType: (_a = options.contentType) !== null && _a !== void 0 ? _a : \"multipart/form-data\",\n    body: {\n      file: uint8ArrayToString(body[\"file\"], \"base64\"),\n      filename: body[\"filename\"],\n      response_format: body[\"responseFormat\"],\n      prompt: body[\"prompt\"],\n      temperature: body[\"temperature\"],\n      model: body[\"model\"]\n    }\n  }));\n}\nexport async function _getAudioTranslationAsResponseObjectDeserialize(result) {\n  if (isUnexpected(result)) {\n    throw result.body;\n  }\n  return {\n    text: result.body[\"text\"],\n    task: result.body[\"task\"],\n    language: result.body[\"language\"],\n    duration: result.body[\"duration\"],\n    segments: !result.body[\"segments\"] ? result.body[\"segments\"] : result.body[\"segments\"].map(p => ({\n      id: p[\"id\"],\n      start: p[\"start\"],\n      end: p[\"end\"],\n      text: p[\"text\"],\n      temperature: p[\"temperature\"],\n      avgLogprob: p[\"avg_logprob\"],\n      compressionRatio: p[\"compression_ratio\"],\n      noSpeechProb: p[\"no_speech_prob\"],\n      tokens: p[\"tokens\"],\n      seek: p[\"seek\"]\n    }))\n  };\n}\n/** Gets English language transcribed text and associated metadata from provided spoken audio data. */\nexport async function getAudioTranslationAsResponseObject(context, deploymentId, body, options = {\n  requestOptions: {}\n}) {\n  const result = await _getAudioTranslationAsResponseObjectSend(context, deploymentId, body, options);\n  return _getAudioTranslationAsResponseObjectDeserialize(result);\n}\nexport function _getCompletionsSend(context, deploymentId, body, options = {\n  requestOptions: {}\n}) {\n  return context.path(\"/deployments/{deploymentId}/completions\", deploymentId).post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), {\n    body: {\n      prompt: body[\"prompt\"],\n      max_tokens: body[\"maxTokens\"],\n      temperature: body[\"temperature\"],\n      top_p: body[\"topP\"],\n      logit_bias: body[\"logitBias\"],\n      user: body[\"user\"],\n      n: body[\"n\"],\n      logprobs: body[\"logprobs\"],\n      echo: body[\"echo\"],\n      stop: body[\"stop\"],\n      presence_penalty: body[\"presencePenalty\"],\n      frequency_penalty: body[\"frequencyPenalty\"],\n      best_of: body[\"bestOf\"],\n      stream: body[\"stream\"],\n      model: body[\"model\"]\n    }\n  }));\n}\n/**\n * Gets completions for the provided input prompts.\n * Completions support a wide variety of tasks and generate text that continues from or \"completes\"\n * provided prompt data.\n */\nexport async function getCompletions(context, deploymentName, prompt, options = {\n  requestOptions: {}\n}) {\n  const {\n      abortSignal,\n      onResponse,\n      requestOptions,\n      tracingOptions\n    } = options,\n    rest = __rest(options, [\"abortSignal\", \"onResponse\", \"requestOptions\", \"tracingOptions\"]);\n  const response = await _getCompletionsSend(context, deploymentName, Object.assign({\n    prompt\n  }, rest), {\n    abortSignal,\n    onResponse,\n    requestOptions,\n    tracingOptions\n  });\n  return _getCompletionsDeserialize(response);\n}\nexport async function _getCompletionsDeserialize(result) {\n  if (isUnexpected(result)) {\n    throw result.body.error;\n  }\n  return getCompletionsResult(result.body);\n}\nexport async function _getChatCompletionsDeserialize(result) {\n  if (isUnexpected(result)) {\n    throw result.body.error;\n  }\n  return getChatCompletionsResult(result.body);\n}\nexport function _getImageGenerationsSend(context, deploymentId, body, options = {\n  requestOptions: {}\n}) {\n  return context.path(\"/deployments/{deploymentId}/images/generations\", deploymentId).post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), {\n    body: {\n      model: body[\"model\"],\n      prompt: body[\"prompt\"],\n      n: body[\"n\"],\n      size: body[\"size\"],\n      response_format: body[\"responseFormat\"],\n      quality: body[\"quality\"],\n      style: body[\"style\"],\n      user: body[\"user\"]\n    }\n  }));\n}\nexport async function _getImageGenerationsDeserialize(result) {\n  if (isUnexpected(result)) {\n    throw result.body.error;\n  }\n  return {\n    created: new Date(result.body[\"created\"]),\n    data: result.body[\"data\"].map(p => ({\n      url: p[\"url\"],\n      base64Data: p[\"b64_json\"],\n      revisedPrompt: p[\"revised_prompt\"]\n    }))\n  };\n}\n/** Creates an image given a prompt. */\nexport async function getImageGenerations(context, deploymentId, body, options = {\n  requestOptions: {}\n}) {\n  const result = await _getImageGenerationsSend(context, deploymentId, body, options);\n  return _getImageGenerationsDeserialize(result);\n}\nexport function _getEmbeddingsSend(context, deploymentId, body, options = {\n  requestOptions: {}\n}) {\n  return context.path(\"/deployments/{deploymentId}/embeddings\", deploymentId).post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), {\n    body: {\n      user: body[\"user\"],\n      model: body[\"model\"],\n      input: body[\"input\"]\n    }\n  }));\n}\nexport async function _getEmbeddingsDeserialize(result) {\n  if (isUnexpected(result)) {\n    throw result.body.error;\n  }\n  return {\n    data: result.body[\"data\"].map(p => ({\n      embedding: p[\"embedding\"],\n      index: p[\"index\"]\n    })),\n    usage: {\n      promptTokens: result.body.usage[\"prompt_tokens\"],\n      totalTokens: result.body.usage[\"total_tokens\"]\n    }\n  };\n}\n/** Return the embeddings for a given prompt. */\nexport async function getEmbeddings(context, deploymentId, body, options = {\n  requestOptions: {}\n}) {\n  const result = await _getEmbeddingsSend(context, deploymentId, body, options);\n  return _getEmbeddingsDeserialize(result);\n}\nexport function streamCompletions(context, deploymentName, prompt, options = {\n  requestOptions: {}\n}) {\n  const {\n      abortSignal,\n      onResponse,\n      requestOptions,\n      tracingOptions\n    } = options,\n    rest = __rest(options, [\"abortSignal\", \"onResponse\", \"requestOptions\", \"tracingOptions\"]);\n  const response = _getCompletionsSend(context, deploymentName, Object.assign(Object.assign({\n    prompt\n  }, rest), {\n    stream: true\n  }), {\n    abortSignal,\n    onResponse,\n    requestOptions,\n    tracingOptions\n  });\n  return getOaiSSEs(response, getCompletionsResult);\n}\nexport async function getImages(context, deploymentName, prompt, options = {\n  requestOptions: {}\n}) {\n  const {\n      abortSignal,\n      onResponse,\n      requestOptions,\n      tracingOptions\n    } = options,\n    rest = __rest(options, [\"abortSignal\", \"onResponse\", \"requestOptions\", \"tracingOptions\"]);\n  const result = await _getImageGenerationsSend(context, deploymentName, Object.assign({\n    prompt\n  }, rest), {\n    abortSignal,\n    onResponse,\n    requestOptions,\n    tracingOptions\n  });\n  return _getImageGenerationsDeserialize(result);\n}\nexport function streamChatCompletions(context, deploymentName, messages, options = {\n  requestOptions: {}\n}) {\n  const response = _getChatCompletionsSendX(context, deploymentName, messages, Object.assign(Object.assign({}, options), {\n    stream: true\n  }));\n  return getOaiSSEs(response, getChatCompletionsResult);\n}\n/**\n * Gets chat completions for the provided chat messages.\n * Completions support a wide variety of tasks and generate text that continues from or \"completes\"\n * provided prompt data.\n */\nexport async function getChatCompletions(context, deploymentName, messages, options = {\n  requestOptions: {}\n}) {\n  const result = await _getChatCompletionsSendX(context, deploymentName, messages, options);\n  return _getChatCompletionsDeserialize(result);\n}\nexport async function getAudioTranslation(context, deploymentName, fileContent, formatOrOptions, inputOptions) {\n  const options = inputOptions !== null && inputOptions !== void 0 ? inputOptions : typeof formatOrOptions === \"string\" ? {} : formatOrOptions !== null && formatOrOptions !== void 0 ? formatOrOptions : {};\n  const response_format = typeof formatOrOptions === \"string\" ? formatOrOptions : undefined;\n  const {\n      abortSignal,\n      onResponse,\n      requestOptions,\n      tracingOptions\n    } = options,\n    rest = __rest(options, [\"abortSignal\", \"onResponse\", \"requestOptions\", \"tracingOptions\"]);\n  const {\n    body,\n    status\n  } = await context.pathUnchecked(\"deployments/{deploymentName}/audio/translations\", deploymentName).post(Object.assign(Object.assign({}, operationOptionsToRequestParameters({\n    abortSignal,\n    onResponse,\n    tracingOptions,\n    requestOptions\n  })), {\n    contentType: \"multipart/form-data\",\n    body: Object.assign(Object.assign(Object.assign({}, snakeCaseKeys(rest)), {\n      file: createFile(fileContent, \"placeholder.wav\")\n    }), response_format ? {\n      response_format\n    } : {})\n  }));\n  if (status !== \"200\") {\n    throw body.error;\n  }\n  return response_format !== \"verbose_json\" ? body : camelCaseKeys(body);\n}\nexport async function getAudioTranscription(context, deploymentName, fileContent, formatOrOptions, inputOptions) {\n  const options = inputOptions !== null && inputOptions !== void 0 ? inputOptions : typeof formatOrOptions === \"string\" ? {} : formatOrOptions !== null && formatOrOptions !== void 0 ? formatOrOptions : {};\n  const response_format = typeof formatOrOptions === \"string\" ? formatOrOptions : undefined;\n  const {\n      abortSignal,\n      onResponse,\n      requestOptions,\n      tracingOptions\n    } = options,\n    rest = __rest(options, [\"abortSignal\", \"onResponse\", \"requestOptions\", \"tracingOptions\"]);\n  const {\n    body,\n    status\n  } = await context.pathUnchecked(\"deployments/{deploymentName}/audio/transcriptions\", deploymentName).post(Object.assign(Object.assign({}, operationOptionsToRequestParameters({\n    abortSignal,\n    onResponse,\n    tracingOptions,\n    requestOptions\n  })), {\n    contentType: \"multipart/form-data\",\n    body: Object.assign(Object.assign(Object.assign({}, snakeCaseKeys(rest)), {\n      file: createFile(fileContent, \"placeholder.wav\")\n    }), response_format ? {\n      response_format\n    } : {})\n  }));\n  if (status !== \"200\") {\n    throw body.error;\n  }\n  return response_format !== \"verbose_json\" ? body : camelCaseKeys(body);\n}\nfunction _getChatCompletionsSendX(context, deploymentName, messages, options = {\n  requestOptions: {}\n}) {\n  const {\n      azureExtensionOptions,\n      abortSignal,\n      onResponse,\n      requestOptions,\n      tracingOptions\n    } = options,\n    rest = __rest(options, [\"azureExtensionOptions\", \"abortSignal\", \"onResponse\", \"requestOptions\", \"tracingOptions\"]);\n  const coreOptions = {\n    abortSignal,\n    onResponse,\n    requestOptions,\n    tracingOptions\n  };\n  const azure = Object.assign(Object.assign({}, !(azureExtensionOptions === null || azureExtensionOptions === void 0 ? void 0 : azureExtensionOptions.extensions) ? {} : {\n    dataSources: azureExtensionOptions.extensions\n  }), !(azureExtensionOptions === null || azureExtensionOptions === void 0 ? void 0 : azureExtensionOptions.enhancements) ? {} : {\n    enhancements: azureExtensionOptions.enhancements\n  });\n  return azure.dataSources || azure.enhancements ? _getChatCompletionsWithAzureExtensionsSend(context, deploymentName, Object.assign(Object.assign({\n    messages\n  }, rest), azure), coreOptions) : _getChatCompletionsSend(context, deploymentName, Object.assign({\n    messages\n  }, rest), coreOptions);\n}\nfunction _getChatCompletionsWithAzureExtensionsSend(context, deploymentName, body, options = {\n  requestOptions: {}\n}) {\n  const {\n      functions,\n      functionCall,\n      messages,\n      dataSources\n    } = body,\n    rest = __rest(body, [\"functions\", \"functionCall\", \"messages\", \"dataSources\"]);\n  return context.path(\"/deployments/{deploymentId}/extensions/chat/completions\", deploymentName).post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), {\n    body: Object.assign(Object.assign({}, snakeCaseKeys(rest)), {\n      dataSources: dataSources === null || dataSources === void 0 ? void 0 : dataSources.map(_a => {\n        var {\n            type\n          } = _a,\n          opts = __rest(_a, [\"type\"]);\n        return {\n          type,\n          parameters: opts\n        };\n      }),\n      functions,\n      function_call: functionCall,\n      messages: messages.map(serializeChatRequestMessage)\n    })\n  }));\n}\nfunction serializeChatRequestMessage(message) {\n  if (message.content === undefined) {\n    message.content = null;\n  }\n  switch (message.role) {\n    case \"assistant\":\n      {\n        const {\n            functionCall,\n            toolCalls\n          } = message,\n          rest = __rest(message, [\"functionCall\", \"toolCalls\"]);\n        return Object.assign(Object.assign(Object.assign({}, snakeCaseKeys(rest)), !toolCalls || toolCalls.length === 0 ? {} : {\n          tool_calls: toolCalls\n        }), functionCall ? {\n          function_call: functionCall\n        } : {});\n      }\n    default:\n      {\n        return snakeCaseKeys(message);\n      }\n  }\n}\nfunction _getChatCompletionsSend(context, deploymentName, body, options = {\n  requestOptions: {}\n}) {\n  const {\n      functions,\n      functionCall,\n      messages\n    } = body,\n    rest = __rest(body, [\"functions\", \"functionCall\", \"messages\"]);\n  return context.path(\"/deployments/{deploymentId}/chat/completions\", deploymentName).post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), {\n    body: Object.assign(Object.assign({}, snakeCaseKeys(rest)), {\n      functions,\n      function_call: functionCall,\n      messages: messages.map(serializeChatRequestMessage)\n    })\n  }));\n}\nexport async function _getChatCompletionsWithAzureExtensionsDeserialize() {\n  return {};\n}\nexport async function getChatCompletionsWithAzureExtensions(_context, _deploymentId, _body, _options = {}) {\n  return {};\n}","map":{"version":3,"names":["operationOptionsToRequestParameters","createFile","uint8ArrayToString","isUnexpected","getOaiSSEs","camelCaseKeys","snakeCaseKeys","getChatCompletionsResult","getCompletionsResult","_getAudioTranscriptionAsPlainTextSend","context","deploymentId","body","options","requestOptions","path","post","Object","assign","file","filename","response_format","language","prompt","temperature","model","_getAudioTranscriptionAsPlainTextDeserialize","result","getAudioTranscriptionAsPlainText","_getAudioTranscriptionAsResponseObjectSend","contentType","_a","_getAudioTranscriptionAsResponseObjectDeserialize","text","task","duration","segments","map","p","id","start","end","avgLogprob","compressionRatio","noSpeechProb","tokens","seek","getAudioTranscriptionAsResponseObject","_getAudioTranslationAsPlainTextSend","_getAudioTranslationAsPlainTextDeserialize","getAudioTranslationAsPlainText","_getAudioTranslationAsResponseObjectSend","_getAudioTranslationAsResponseObjectDeserialize","getAudioTranslationAsResponseObject","_getCompletionsSend","max_tokens","top_p","logit_bias","user","n","logprobs","echo","stop","presence_penalty","frequency_penalty","best_of","stream","getCompletions","deploymentName","abortSignal","onResponse","tracingOptions","rest","__rest","response","_getCompletionsDeserialize","error","_getChatCompletionsDeserialize","_getImageGenerationsSend","size","quality","style","_getImageGenerationsDeserialize","created","Date","data","url","base64Data","revisedPrompt","getImageGenerations","_getEmbeddingsSend","input","_getEmbeddingsDeserialize","embedding","index","usage","promptTokens","totalTokens","getEmbeddings","streamCompletions","getImages","streamChatCompletions","messages","_getChatCompletionsSendX","getChatCompletions","getAudioTranslation","fileContent","formatOrOptions","inputOptions","undefined","status","pathUnchecked","getAudioTranscription","azureExtensionOptions","coreOptions","azure","extensions","dataSources","enhancements","_getChatCompletionsWithAzureExtensionsSend","_getChatCompletionsSend","functions","functionCall","type","opts","parameters","function_call","serializeChatRequestMessage","message","content","role","toolCalls","length","tool_calls","_getChatCompletionsWithAzureExtensionsDeserialize","getChatCompletionsWithAzureExtensions","_context","_deploymentId","_body","_options"],"sources":["/workspaces/codespaces-blank/jupyter_react/node_modules/@azure/openai/src/api/client/openAIClient/index.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * THIS IS AN AUTO-GENERATED FILE - DO NOT EDIT!\n *\n * Any changes you make here may be lost.\n *\n * If you need to make changes, please do so in the original source file, \\{project-root\\}/sources/custom\n */\n\nimport { StreamableMethod, operationOptionsToRequestParameters } from \"@azure-rest/core-client\";\nimport { createFile } from \"@azure/core-rest-pipeline\";\nimport { uint8ArrayToString } from \"@azure/core-util\";\nimport {\n  AudioResult,\n  AudioResultFormat,\n  AudioResultSimpleJson,\n  GetAudioTranscriptionOptions,\n  GetAudioTranslationOptions,\n} from \"../../../models/audio.js\";\nimport {\n  AudioTranscription,\n  AudioTranscriptionOptions,\n  AudioTranslation,\n  AudioTranslationOptions,\n  ChatCompletions,\n  ChatCompletionsOptions,\n  ChatRequestMessage,\n  Completions,\n  CompletionsOptions,\n  Embeddings,\n  EmbeddingsOptions,\n  EventStream,\n  ImageGenerations,\n} from \"../../../models/models.js\";\nimport {\n  ClientOpenAIClientGetAudioTranscriptionAsPlainTextOptions,\n  ClientOpenAIClientGetAudioTranscriptionAsResponseObjectOptions,\n  ClientOpenAIClientGetAudioTranslationAsPlainTextOptions,\n  ClientOpenAIClientGetAudioTranslationAsResponseObjectOptions,\n  ClientOpenAIClientGetChatCompletionsOptions,\n  ClientOpenAIClientGetChatCompletionsWithAzureExtensionsOptions,\n  ClientOpenAIClientGetCompletionsOptions,\n  ClientOpenAIClientGetEmbeddingsOptions,\n  ClientOpenAIClientGetImageGenerationsOptions,\n  GetChatCompletionsOptions,\n  GetCompletionsOptions,\n  GetImagesOptions,\n} from \"../../../models/options.js\";\nimport {\n  AzureChatExtensionConfiguration,\n  OpenAIContext as Client,\n  GetAudioTranscriptionAsPlainText200Response,\n  GetAudioTranscriptionAsPlainTextDefaultResponse,\n  GetAudioTranscriptionAsResponseObject200Response,\n  GetAudioTranscriptionAsResponseObjectDefaultResponse,\n  GetAudioTranslationAsPlainText200Response,\n  GetAudioTranslationAsPlainTextDefaultResponse,\n  GetAudioTranslationAsResponseObject200Response,\n  GetAudioTranslationAsResponseObjectDefaultResponse,\n  GetChatCompletions200Response,\n  GetChatCompletionsDefaultResponse,\n  GetChatCompletionsWithAzureExtensions200Response,\n  GetChatCompletionsWithAzureExtensionsDefaultResponse,\n  GetCompletions200Response,\n  GetCompletionsDefaultResponse,\n  GetEmbeddings200Response,\n  GetEmbeddingsDefaultResponse,\n  GetImageGenerations200Response,\n  GetImageGenerationsDefaultResponse,\n  isUnexpected,\n  ChatRequestMessage as RestChatRequestMessage,\n} from \"../../../rest/index.js\";\nimport { getOaiSSEs } from \"../../oaiSse.js\";\nimport { camelCaseKeys, snakeCaseKeys } from \"../../util.js\";\nimport { getChatCompletionsResult, getCompletionsResult } from \"./deserializers.js\";\nimport {\n  ChatCompletionsOptions as GeneratedChatCompletionsOptions,\n  ImageGenerationOptions as GeneratedImageGenerationOptions,\n} from \"../../../models/models.js\";\n\nexport function _getAudioTranscriptionAsPlainTextSend(\n  context: Client,\n  deploymentId: string,\n  body: AudioTranscriptionOptions,\n  options: ClientOpenAIClientGetAudioTranscriptionAsPlainTextOptions = {\n    requestOptions: {},\n  },\n): StreamableMethod<\n  GetAudioTranscriptionAsPlainText200Response | GetAudioTranscriptionAsPlainTextDefaultResponse\n> {\n  return context.path(\"/deployments/{deploymentId}/audio/transcriptions\", deploymentId).post({\n    ...operationOptionsToRequestParameters(options),\n    body: {\n      file: uint8ArrayToString(body[\"file\"], \"base64\"),\n      filename: body[\"filename\"],\n      response_format: body[\"responseFormat\"],\n      language: body[\"language\"],\n      prompt: body[\"prompt\"],\n      temperature: body[\"temperature\"],\n      model: body[\"model\"],\n    },\n  }) as StreamableMethod<\n    GetAudioTranscriptionAsPlainText200Response | GetAudioTranscriptionAsPlainTextDefaultResponse\n  >;\n}\n\nexport async function _getAudioTranscriptionAsPlainTextDeserialize(\n  result:\n    | GetAudioTranscriptionAsPlainText200Response\n    | GetAudioTranscriptionAsPlainTextDefaultResponse,\n): Promise<string> {\n  if (isUnexpected(result)) {\n    throw result.body;\n  }\n\n  return result.body;\n}\n\n/**\n * Gets transcribed text and associated metadata from provided spoken audio data. Audio will be transcribed in the\n * written language corresponding to the language it was spoken in.\n */\nexport async function getAudioTranscriptionAsPlainText(\n  context: Client,\n  deploymentId: string,\n  body: AudioTranscriptionOptions,\n  options: ClientOpenAIClientGetAudioTranscriptionAsPlainTextOptions = {\n    requestOptions: {},\n  },\n): Promise<string> {\n  const result = await _getAudioTranscriptionAsPlainTextSend(context, deploymentId, body, options);\n  return _getAudioTranscriptionAsPlainTextDeserialize(result);\n}\n\nexport function _getAudioTranscriptionAsResponseObjectSend(\n  context: Client,\n  deploymentId: string,\n  body: AudioTranscriptionOptions,\n  options: ClientOpenAIClientGetAudioTranscriptionAsResponseObjectOptions = {\n    requestOptions: {},\n  },\n): StreamableMethod<\n  | GetAudioTranscriptionAsResponseObject200Response\n  | GetAudioTranscriptionAsResponseObjectDefaultResponse\n> {\n  return context.path(\"/deployments/{deploymentId}/audio/transcriptions\", deploymentId).post({\n    ...operationOptionsToRequestParameters(options),\n    contentType: (options.contentType as any) ?? \"multipart/form-data\",\n    body: {\n      file: uint8ArrayToString(body[\"file\"], \"base64\"),\n      filename: body[\"filename\"],\n      response_format: body[\"responseFormat\"],\n      language: body[\"language\"],\n      prompt: body[\"prompt\"],\n      temperature: body[\"temperature\"],\n      model: body[\"model\"],\n    },\n  }) as StreamableMethod<\n    | GetAudioTranscriptionAsResponseObject200Response\n    | GetAudioTranscriptionAsResponseObjectDefaultResponse\n  >;\n}\n\nexport async function _getAudioTranscriptionAsResponseObjectDeserialize(\n  result:\n    | GetAudioTranscriptionAsResponseObject200Response\n    | GetAudioTranscriptionAsResponseObjectDefaultResponse,\n): Promise<AudioTranscription> {\n  if (isUnexpected(result)) {\n    throw result.body;\n  }\n\n  return {\n    text: result.body[\"text\"],\n    task: result.body[\"task\"],\n    language: result.body[\"language\"],\n    duration: result.body[\"duration\"],\n    segments: !result.body[\"segments\"]\n      ? result.body[\"segments\"]\n      : result.body[\"segments\"].map((p) => ({\n          id: p[\"id\"],\n          start: p[\"start\"],\n          end: p[\"end\"],\n          text: p[\"text\"],\n          temperature: p[\"temperature\"],\n          avgLogprob: p[\"avg_logprob\"],\n          compressionRatio: p[\"compression_ratio\"],\n          noSpeechProb: p[\"no_speech_prob\"],\n          tokens: p[\"tokens\"],\n          seek: p[\"seek\"],\n        })),\n  };\n}\n\n/**\n * Gets transcribed text and associated metadata from provided spoken audio data. Audio will be transcribed in the\n * written language corresponding to the language it was spoken in.\n */\nexport async function getAudioTranscriptionAsResponseObject(\n  context: Client,\n  deploymentId: string,\n  body: AudioTranscriptionOptions,\n  options: ClientOpenAIClientGetAudioTranscriptionAsResponseObjectOptions = {\n    requestOptions: {},\n  },\n): Promise<AudioTranscription> {\n  const result = await _getAudioTranscriptionAsResponseObjectSend(\n    context,\n    deploymentId,\n    body,\n    options,\n  );\n  return _getAudioTranscriptionAsResponseObjectDeserialize(result);\n}\n\nexport function _getAudioTranslationAsPlainTextSend(\n  context: Client,\n  deploymentId: string,\n  body: AudioTranslationOptions,\n  options: ClientOpenAIClientGetAudioTranslationAsPlainTextOptions = {\n    requestOptions: {},\n  },\n): StreamableMethod<\n  GetAudioTranslationAsPlainText200Response | GetAudioTranslationAsPlainTextDefaultResponse\n> {\n  return context.path(\"/deployments/{deploymentId}/audio/translations\", deploymentId).post({\n    ...operationOptionsToRequestParameters(options),\n    body: {\n      file: uint8ArrayToString(body[\"file\"], \"base64\"),\n      filename: body[\"filename\"],\n      response_format: body[\"responseFormat\"],\n      prompt: body[\"prompt\"],\n      temperature: body[\"temperature\"],\n      model: body[\"model\"],\n    },\n  }) as StreamableMethod<\n    GetAudioTranslationAsPlainText200Response | GetAudioTranslationAsPlainTextDefaultResponse\n  >;\n}\n\nexport async function _getAudioTranslationAsPlainTextDeserialize(\n  result: GetAudioTranslationAsPlainText200Response | GetAudioTranslationAsPlainTextDefaultResponse,\n): Promise<string> {\n  if (isUnexpected(result)) {\n    throw result.body;\n  }\n\n  return result.body;\n}\n\n/** Gets English language transcribed text and associated metadata from provided spoken audio data. */\nexport async function getAudioTranslationAsPlainText(\n  context: Client,\n  deploymentId: string,\n  body: AudioTranslationOptions,\n  options: ClientOpenAIClientGetAudioTranslationAsPlainTextOptions = {\n    requestOptions: {},\n  },\n): Promise<string> {\n  const result = await _getAudioTranslationAsPlainTextSend(context, deploymentId, body, options);\n  return _getAudioTranslationAsPlainTextDeserialize(result);\n}\n\nexport function _getAudioTranslationAsResponseObjectSend(\n  context: Client,\n  deploymentId: string,\n  body: AudioTranslationOptions,\n  options: ClientOpenAIClientGetAudioTranslationAsResponseObjectOptions = {\n    requestOptions: {},\n  },\n): StreamableMethod<\n  | GetAudioTranslationAsResponseObject200Response\n  | GetAudioTranslationAsResponseObjectDefaultResponse\n> {\n  return context.path(\"/deployments/{deploymentId}/audio/translations\", deploymentId).post({\n    ...operationOptionsToRequestParameters(options),\n    contentType: (options.contentType as any) ?? \"multipart/form-data\",\n    body: {\n      file: uint8ArrayToString(body[\"file\"], \"base64\"),\n      filename: body[\"filename\"],\n      response_format: body[\"responseFormat\"],\n      prompt: body[\"prompt\"],\n      temperature: body[\"temperature\"],\n      model: body[\"model\"],\n    },\n  }) as StreamableMethod<\n    | GetAudioTranslationAsResponseObject200Response\n    | GetAudioTranslationAsResponseObjectDefaultResponse\n  >;\n}\n\nexport async function _getAudioTranslationAsResponseObjectDeserialize(\n  result:\n    | GetAudioTranslationAsResponseObject200Response\n    | GetAudioTranslationAsResponseObjectDefaultResponse,\n): Promise<AudioTranslation> {\n  if (isUnexpected(result)) {\n    throw result.body;\n  }\n\n  return {\n    text: result.body[\"text\"],\n    task: result.body[\"task\"],\n    language: result.body[\"language\"],\n    duration: result.body[\"duration\"],\n    segments: !result.body[\"segments\"]\n      ? result.body[\"segments\"]\n      : result.body[\"segments\"].map((p) => ({\n          id: p[\"id\"],\n          start: p[\"start\"],\n          end: p[\"end\"],\n          text: p[\"text\"],\n          temperature: p[\"temperature\"],\n          avgLogprob: p[\"avg_logprob\"],\n          compressionRatio: p[\"compression_ratio\"],\n          noSpeechProb: p[\"no_speech_prob\"],\n          tokens: p[\"tokens\"],\n          seek: p[\"seek\"],\n        })),\n  };\n}\n\n/** Gets English language transcribed text and associated metadata from provided spoken audio data. */\nexport async function getAudioTranslationAsResponseObject(\n  context: Client,\n  deploymentId: string,\n  body: AudioTranslationOptions,\n  options: ClientOpenAIClientGetAudioTranslationAsResponseObjectOptions = {\n    requestOptions: {},\n  },\n): Promise<AudioTranslation> {\n  const result = await _getAudioTranslationAsResponseObjectSend(\n    context,\n    deploymentId,\n    body,\n    options,\n  );\n  return _getAudioTranslationAsResponseObjectDeserialize(result);\n}\n\nexport function _getCompletionsSend(\n  context: Client,\n  deploymentId: string,\n  body: CompletionsOptions,\n  options: ClientOpenAIClientGetCompletionsOptions = { requestOptions: {} },\n): StreamableMethod<GetCompletions200Response | GetCompletionsDefaultResponse> {\n  return context.path(\"/deployments/{deploymentId}/completions\", deploymentId).post({\n    ...operationOptionsToRequestParameters(options),\n    body: {\n      prompt: body[\"prompt\"],\n      max_tokens: body[\"maxTokens\"],\n      temperature: body[\"temperature\"],\n      top_p: body[\"topP\"],\n      logit_bias: body[\"logitBias\"],\n      user: body[\"user\"],\n      n: body[\"n\"],\n      logprobs: body[\"logprobs\"],\n      echo: body[\"echo\"],\n      stop: body[\"stop\"],\n      presence_penalty: body[\"presencePenalty\"],\n      frequency_penalty: body[\"frequencyPenalty\"],\n      best_of: body[\"bestOf\"],\n      stream: body[\"stream\"],\n      model: body[\"model\"],\n    },\n  });\n}\n\n/**\n * Gets completions for the provided input prompts.\n * Completions support a wide variety of tasks and generate text that continues from or \"completes\"\n * provided prompt data.\n */\nexport async function getCompletions(\n  context: Client,\n  deploymentName: string,\n  prompt: string[],\n  options: GetCompletionsOptions = { requestOptions: {} },\n): Promise<Completions> {\n  const { abortSignal, onResponse, requestOptions, tracingOptions, ...rest } = options;\n  const response = await _getCompletionsSend(\n    context,\n    deploymentName,\n    {\n      prompt,\n      ...rest,\n    },\n    { abortSignal, onResponse, requestOptions, tracingOptions },\n  );\n  return _getCompletionsDeserialize(response);\n}\n\nexport async function _getCompletionsDeserialize(\n  result: GetCompletions200Response | GetCompletionsDefaultResponse,\n): Promise<Completions> {\n  if (isUnexpected(result)) {\n    throw result.body.error;\n  }\n  return getCompletionsResult(result.body);\n}\n\nexport async function _getChatCompletionsDeserialize(\n  result: GetChatCompletions200Response | GetChatCompletionsDefaultResponse,\n): Promise<ChatCompletions> {\n  if (isUnexpected(result)) {\n    throw result.body.error;\n  }\n  return getChatCompletionsResult(result.body);\n}\n\nexport function _getImageGenerationsSend(\n  context: Client,\n  deploymentId: string,\n  body: GeneratedImageGenerationOptions,\n  options: ClientOpenAIClientGetImageGenerationsOptions = { requestOptions: {} },\n): StreamableMethod<GetImageGenerations200Response | GetImageGenerationsDefaultResponse> {\n  return context.path(\"/deployments/{deploymentId}/images/generations\", deploymentId).post({\n    ...operationOptionsToRequestParameters(options),\n    body: {\n      model: body[\"model\"],\n      prompt: body[\"prompt\"],\n      n: body[\"n\"],\n      size: body[\"size\"],\n      response_format: body[\"responseFormat\"],\n      quality: body[\"quality\"],\n      style: body[\"style\"],\n      user: body[\"user\"],\n    },\n  });\n}\n\nexport async function _getImageGenerationsDeserialize(\n  result: GetImageGenerations200Response | GetImageGenerationsDefaultResponse,\n): Promise<ImageGenerations> {\n  if (isUnexpected(result)) {\n    throw result.body.error;\n  }\n\n  return {\n    created: new Date(result.body[\"created\"]),\n    data: result.body[\"data\"].map((p) => ({\n      url: p[\"url\"],\n      base64Data: p[\"b64_json\"],\n      revisedPrompt: p[\"revised_prompt\"],\n    })),\n  };\n}\n\n/** Creates an image given a prompt. */\nexport async function getImageGenerations(\n  context: Client,\n  deploymentId: string,\n  body: GeneratedImageGenerationOptions,\n  options: ClientOpenAIClientGetImageGenerationsOptions = { requestOptions: {} },\n): Promise<ImageGenerations> {\n  const result = await _getImageGenerationsSend(context, deploymentId, body, options);\n  return _getImageGenerationsDeserialize(result);\n}\n\nexport function _getEmbeddingsSend(\n  context: Client,\n  deploymentId: string,\n  body: EmbeddingsOptions,\n  options: ClientOpenAIClientGetEmbeddingsOptions = { requestOptions: {} },\n): StreamableMethod<GetEmbeddings200Response | GetEmbeddingsDefaultResponse> {\n  return context.path(\"/deployments/{deploymentId}/embeddings\", deploymentId).post({\n    ...operationOptionsToRequestParameters(options),\n    body: { user: body[\"user\"], model: body[\"model\"], input: body[\"input\"] },\n  });\n}\n\nexport async function _getEmbeddingsDeserialize(\n  result: GetEmbeddings200Response | GetEmbeddingsDefaultResponse,\n): Promise<Embeddings> {\n  if (isUnexpected(result)) {\n    throw result.body.error;\n  }\n\n  return {\n    data: result.body[\"data\"].map((p) => ({\n      embedding: p[\"embedding\"],\n      index: p[\"index\"],\n    })),\n    usage: {\n      promptTokens: result.body.usage[\"prompt_tokens\"],\n      totalTokens: result.body.usage[\"total_tokens\"],\n    },\n  };\n}\n\n/** Return the embeddings for a given prompt. */\nexport async function getEmbeddings(\n  context: Client,\n  deploymentId: string,\n  body: EmbeddingsOptions,\n  options: ClientOpenAIClientGetEmbeddingsOptions = { requestOptions: {} },\n): Promise<Embeddings> {\n  const result = await _getEmbeddingsSend(context, deploymentId, body, options);\n  return _getEmbeddingsDeserialize(result);\n}\n\nexport function streamCompletions(\n  context: Client,\n  deploymentName: string,\n  prompt: string[],\n  options: GetCompletionsOptions = { requestOptions: {} },\n): Promise<EventStream<Omit<Completions, \"usage\">>> {\n  const { abortSignal, onResponse, requestOptions, tracingOptions, ...rest } = options;\n  const response = _getCompletionsSend(\n    context,\n    deploymentName,\n    {\n      prompt,\n      ...rest,\n      stream: true,\n    },\n    { abortSignal, onResponse, requestOptions, tracingOptions },\n  );\n  return getOaiSSEs(response, getCompletionsResult);\n}\n\nexport async function getImages(\n  context: Client,\n  deploymentName: string,\n  prompt: string,\n  options: GetImagesOptions = { requestOptions: {} },\n): Promise<ImageGenerations> {\n  const { abortSignal, onResponse, requestOptions, tracingOptions, ...rest } = options;\n  const result = await _getImageGenerationsSend(\n    context,\n    deploymentName,\n    { prompt, ...rest },\n    { abortSignal, onResponse, requestOptions, tracingOptions },\n  );\n  return _getImageGenerationsDeserialize(result);\n}\n\nexport function streamChatCompletions(\n  context: Client,\n  deploymentName: string,\n  messages: ChatRequestMessage[],\n  options: GetChatCompletionsOptions = { requestOptions: {} },\n): Promise<EventStream<ChatCompletions>> {\n  const response = _getChatCompletionsSendX(context, deploymentName, messages, {\n    ...options,\n    stream: true,\n  });\n  return getOaiSSEs(response, getChatCompletionsResult);\n}\n\n/**\n * Gets chat completions for the provided chat messages.\n * Completions support a wide variety of tasks and generate text that continues from or \"completes\"\n * provided prompt data.\n */\nexport async function getChatCompletions(\n  context: Client,\n  deploymentName: string,\n  messages: ChatRequestMessage[],\n  options: GetChatCompletionsOptions = { requestOptions: {} },\n): Promise<ChatCompletions> {\n  const result = await _getChatCompletionsSendX(context, deploymentName, messages, options);\n  return _getChatCompletionsDeserialize(result);\n}\n/**\n * Returns the translation of an audio file.\n * @param context - The context containing the client to use for this request.\n * @param deploymentName - The name of the model deployment (when using Azure OpenAI) or model name (when using non-Azure OpenAI) to use for this request.\n * @param fileContent - The content of the audio file to translate.\n * @param options - The options for this audio translation request.\n * @returns The audio translation result.\n */\nexport async function getAudioTranslation(\n  context: Client,\n  deploymentName: string,\n  fileContent: Uint8Array,\n  options?: GetAudioTranslationOptions,\n): Promise<AudioResultSimpleJson>;\n/**\n * Returns the translation of an audio file.\n * @param context - The context containing the client to use for this request.\n * @param deploymentName - The name of the model deployment (when using Azure OpenAI) or model name (when using non-Azure OpenAI) to use for this request.\n * @param fileContent - The content of the audio file to translate.\n * @param format - The format of the result object. See {@link AudioResultFormat} for possible values.\n * @param options - The options for this audio translation request.\n * @returns The audio translation result.\n */\nexport async function getAudioTranslation<Format extends AudioResultFormat>(\n  context: Client,\n  deploymentName: string,\n  fileContent: Uint8Array,\n  format: Format,\n  options?: GetAudioTranslationOptions,\n): Promise<AudioResult<Format>>;\nexport async function getAudioTranslation<Format extends AudioResultFormat>(\n  context: Client,\n  deploymentName: string,\n  fileContent: Uint8Array,\n  formatOrOptions?: Format | GetAudioTranslationOptions,\n  inputOptions?: GetAudioTranslationOptions,\n): Promise<AudioResult<Format>> {\n  const options =\n    inputOptions ?? (typeof formatOrOptions === \"string\" ? {} : formatOrOptions ?? {});\n  const response_format = typeof formatOrOptions === \"string\" ? formatOrOptions : undefined;\n  const { abortSignal, onResponse, requestOptions, tracingOptions, ...rest } = options;\n  const { body, status } = await context\n    .pathUnchecked(\"deployments/{deploymentName}/audio/translations\", deploymentName)\n    .post({\n      ...operationOptionsToRequestParameters({\n        abortSignal,\n        onResponse,\n        tracingOptions,\n        requestOptions,\n      }),\n      contentType: \"multipart/form-data\",\n      body: {\n        ...snakeCaseKeys(rest),\n        file: createFile(fileContent, \"placeholder.wav\"),\n        ...(response_format ? { response_format } : {}),\n      },\n    });\n  if (status !== \"200\") {\n    throw body.error;\n  }\n\n  return response_format !== \"verbose_json\"\n    ? body\n    : (camelCaseKeys(body) as unknown as AudioResult<Format>);\n}\n\n/**\n * Returns the transcription of an audio file in a simple JSON format.\n * @param context - The context containing the client to use for this request.\n * @param deploymentName - The name of the model deployment (when using Azure OpenAI) or model name (when using non-Azure OpenAI) to use for this request.\n * @param fileContent - The content of the audio file to transcribe.\n * @param options - The options for this audio transcription request.\n * @returns The audio transcription result in a simple JSON format.\n */\nexport async function getAudioTranscription(\n  context: Client,\n  deploymentName: string,\n  fileContent: Uint8Array,\n  options?: GetAudioTranscriptionOptions,\n): Promise<AudioResultSimpleJson>;\n/**\n * Returns the transcription of an audio file.\n * @param context - The context containing the client to use for this request.\n * @param deploymentName - The name of the model deployment (when using Azure OpenAI) or model name (when using non-Azure OpenAI) to use for this request.\n * @param fileContent - The content of the audio file to transcribe.\n * @param format - The format of the result object. See {@link AudioResultFormat} for possible values.\n * @param options - The options for this audio transcription request.\n * @returns The audio transcription result in a format of your choice.\n */\nexport async function getAudioTranscription<Format extends AudioResultFormat>(\n  context: Client,\n  deploymentName: string,\n  fileContent: Uint8Array,\n  format: Format,\n  options?: GetAudioTranscriptionOptions,\n): Promise<AudioResult<Format>>;\nexport async function getAudioTranscription<Format extends AudioResultFormat>(\n  context: Client,\n  deploymentName: string,\n  fileContent: Uint8Array,\n  formatOrOptions?: Format | GetAudioTranscriptionOptions,\n  inputOptions?: GetAudioTranscriptionOptions,\n): Promise<AudioResult<Format>> {\n  const options =\n    inputOptions ?? (typeof formatOrOptions === \"string\" ? {} : formatOrOptions ?? {});\n  const response_format = typeof formatOrOptions === \"string\" ? formatOrOptions : undefined;\n  const { abortSignal, onResponse, requestOptions, tracingOptions, ...rest } = options;\n  const { body, status } = await context\n    .pathUnchecked(\"deployments/{deploymentName}/audio/transcriptions\", deploymentName)\n    .post({\n      ...operationOptionsToRequestParameters({\n        abortSignal,\n        onResponse,\n        tracingOptions,\n        requestOptions,\n      }),\n      contentType: \"multipart/form-data\",\n      body: {\n        ...snakeCaseKeys(rest),\n        file: createFile(fileContent, \"placeholder.wav\"),\n        ...(response_format ? { response_format } : {}),\n      },\n    });\n  if (status !== \"200\") {\n    throw body.error;\n  }\n\n  return response_format !== \"verbose_json\"\n    ? body\n    : (camelCaseKeys(body) as unknown as AudioResult<Format>);\n}\n\nfunction _getChatCompletionsSendX(\n  context: Client,\n  deploymentName: string,\n  messages: ChatRequestMessage[],\n  options: GetChatCompletionsOptions & { stream?: boolean } = { requestOptions: {} },\n): StreamableMethod<\n  | GetChatCompletionsWithAzureExtensions200Response\n  | GetChatCompletionsWithAzureExtensionsDefaultResponse\n> {\n  const {\n    azureExtensionOptions,\n    abortSignal,\n    onResponse,\n    requestOptions,\n    tracingOptions,\n    ...rest\n  } = options;\n  const coreOptions = {\n    abortSignal,\n    onResponse,\n    requestOptions,\n    tracingOptions,\n  };\n  const azure = {\n    ...(!azureExtensionOptions?.extensions\n      ? {}\n      : { dataSources: azureExtensionOptions.extensions }),\n    ...(!azureExtensionOptions?.enhancements\n      ? {}\n      : { enhancements: azureExtensionOptions.enhancements }),\n  };\n  return azure.dataSources || azure.enhancements\n    ? _getChatCompletionsWithAzureExtensionsSend(\n        context,\n        deploymentName,\n        {\n          messages,\n          ...rest,\n          ...azure,\n        },\n        coreOptions,\n      )\n    : _getChatCompletionsSend(context, deploymentName, { messages, ...rest }, coreOptions);\n}\n\nfunction _getChatCompletionsWithAzureExtensionsSend(\n  context: Client,\n  deploymentName: string,\n  body: GeneratedChatCompletionsOptions,\n  options: ClientOpenAIClientGetChatCompletionsOptions = { requestOptions: {} },\n): StreamableMethod<\n  | GetChatCompletionsWithAzureExtensions200Response\n  | GetChatCompletionsWithAzureExtensionsDefaultResponse\n> {\n  const { functions, functionCall, messages, dataSources, ...rest } = body;\n  return context\n    .path(\"/deployments/{deploymentId}/extensions/chat/completions\", deploymentName)\n    .post({\n      ...operationOptionsToRequestParameters(options),\n      body: {\n        ...snakeCaseKeys(rest),\n        dataSources: dataSources?.map(\n          ({ type, ...opts }) => ({ type, parameters: opts }) as AzureChatExtensionConfiguration,\n        ),\n        functions,\n        function_call: functionCall,\n        messages: messages.map(serializeChatRequestMessage),\n      },\n    });\n}\n\nfunction serializeChatRequestMessage(message: ChatRequestMessage): RestChatRequestMessage {\n  if (message.content === undefined) {\n    message.content = null;\n  }\n  switch (message.role) {\n    case \"assistant\": {\n      const { functionCall, toolCalls, ...rest } = message;\n      return {\n        ...snakeCaseKeys(rest),\n        ...(!toolCalls || toolCalls.length === 0 ? {} : { tool_calls: toolCalls }),\n        ...(functionCall ? { function_call: functionCall } : {}),\n      };\n    }\n    default: {\n      return snakeCaseKeys(message);\n    }\n  }\n}\n\nfunction _getChatCompletionsSend(\n  context: Client,\n  deploymentName: string,\n  body: GeneratedChatCompletionsOptions,\n  options: ClientOpenAIClientGetChatCompletionsOptions = { requestOptions: {} },\n): StreamableMethod<GetChatCompletions200Response | GetChatCompletionsDefaultResponse> {\n  const { functions, functionCall, messages, ...rest } = body;\n  return context.path(\"/deployments/{deploymentId}/chat/completions\", deploymentName).post({\n    ...operationOptionsToRequestParameters(options),\n    body: {\n      ...snakeCaseKeys(rest),\n      functions,\n      function_call: functionCall,\n      messages: messages.map(serializeChatRequestMessage),\n    },\n  });\n}\n\nexport async function _getChatCompletionsWithAzureExtensionsDeserialize(): Promise<any> {\n  return {} as any;\n}\n\nexport async function getChatCompletionsWithAzureExtensions(\n  _context: Client,\n  _deploymentId: string,\n  _body: ChatCompletionsOptions,\n  _options: ClientOpenAIClientGetChatCompletionsWithAzureExtensionsOptions = {},\n): Promise<ChatCompletions> {\n  return {} as any;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}